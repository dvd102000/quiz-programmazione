[
  {
    "id": 1,
    "text": "Quando parliamo di: 'una descrizione delle operazioni che devono essere eseguite per risolvere una ce rta classe di  problemi', stiamo definendo un...:",
    "options": [
      "A. programma",
      "B. algortimo",
      "C. diagramma",
      "D. flow chart"
    ],
    "correct": "A"
  },
  {
    "id": 2,
    "text": "Quando parliamo di: 'una successione ordinata di istruzioni (o passi) che definiscono le operazioni da esegu ire su  dei dati per risolvere una classe di problemi' ci riferiamo alla definizione di:",
    "options": [
      "A. programma",
      "B. algortimo",
      "C. diagramma",
      "D. flow chart"
    ],
    "correct": "B"
  },
  {
    "id": 3,
    "text": "Le proprietà degli algoritmi sono:",
    "options": [
      "A. infinitezza, generalità e ambiguità",
      "B. finitezza, generalità e non ambiguità",
      "C. finitezza, generalità e ambiguità",
      "D. finitezza, specificità e non ambiguità"
    ],
    "correct": "B"
  },
  {
    "id": 4,
    "text": "Un flow chart è un:",
    "options": [
      "A. linguaggio informale di tipo grafico per rappresentare gli algoritmi",
      "B. linguaggio formale di tipo testuale per rappresentare gli algoritmi",
      "C. linguaggio informale di tipo testuale per rappresentare gli algoritmi",
      "D. linguaggio formale di tipo grafico per rappresentare gli algoritmi"
    ],
    "correct": "D"
  },
  {
    "id": 5,
    "text": "La scelta, in un diagramma di flusso, è rappresentata da un:",
    "options": [
      "A. rettangolo",
      "B. quadrato",
      "C. rombo",
      "D. cerchio"
    ],
    "correct": "C"
  },
  {
    "id": 6,
    "text": "Le fasi per descrivere un algortitmo con pseudocodifica sono:",
    "options": [
      "B. intestazione,  dichiarativa, scrittura dei risultati",
      "C. intestazione,acquisizione dei dati, esecutiva",
      "D. assegnazione, dichiarativa, esecutiva"
    ],
    "correct": "A"
  },
  {
    "id": 7,
    "text": "Le caratteristiche di un linguaggio di programmazione sono:",
    "options": [
      "A. lessico, istruzioni, semantica",
      "B. alfabeto, sintassi, semantica",
      "C. lessico, sintassi, semantica",
      "D. alfabeto, simboli, semantica"
    ],
    "correct": "C"
  },
  {
    "id": 8,
    "text": "I linguaggi di programmazione so no classificati per:",
    "options": [
      "A. livello",
      "B. complessità",
      "C. ambiguità",
      "D. leggerezza"
    ],
    "correct": "A"
  },
  {
    "id": 9,
    "text": "L'Assembly è un linguaggio:",
    "options": [
      "A. di alto livello",
      "B. di basso livello",
      "C. vicino all'uomo",
      "D. macchina"
    ],
    "correct": "B"
  },
  {
    "id": 10,
    "text": "Per tradurre un linguaggio ad alto livello in linguaggio macchina si utilizza il:",
    "options": [
      "A. traduttore",
      "B. convertitore",
      "C. codice binario",
      "D. compilatore"
    ],
    "correct": "D"
  },
  {
    "id": 11,
    "text": "La fase di problem finding corrisponde a:",
    "options": [
      "B. Rendersi conto del disagio",
      "C. Passare all'azione"
    ],
    "correct": "B"
  },
  {
    "id": 12,
    "text": "La fase di decision making:",
    "options": [
      "B. Precede la fase di problem finding",
      "C. Segue la fase di problem solving",
      "D. Segue la fase di decision taking"
    ],
    "correct": "C"
  },
  {
    "id": 13,
    "text": "Problem analysis corrisponde a:",
    "options": [
      "A. eliminare le cause e rispondere alle domande proste dal problema",
      "B. definire il problema",
      "C. scomporre il problema principalie in secondari",
      "D. passare all'azione"
    ],
    "correct": "C"
  },
  {
    "id": 14,
    "text": "Problem setting vuol dire:",
    "options": [
      "B. Suddividere il problema in  sotto problemi"
    ],
    "correct": "A"
  },
  {
    "id": 15,
    "text": "La fase di decision taking:",
    "options": [
      "A. E' immediatamente successiva alla fase di problem analysis",
      "B. E' imm ediatamente successiva alla fase di decision making",
      "C. Vuol dire decidere come agire",
      "D. Vuol dire rendersi conto della situaizone problematica"
    ],
    "correct": "B"
  },
  {
    "id": 16,
    "text": "Quante sono le mosse per un corretto utilizzo delle tecniche di problem s olving:",
    "options": [
      "A. 6",
      "B. 8",
      "D. 5"
    ],
    "correct": "A"
  },
  {
    "id": 17,
    "text": "L'approccio top -down indica:",
    "options": [
      "A. Una scomposizione di problemi semplici in sotto problemi più complessi",
      "B. Una unione di problemi piccoli in problemi più complessi",
      "C. un approcc io in cui la scomposizione inizia dal livello più basso",
      "D. un approccio in cui la scomposizione inizia dal livello più alto e prosegue verso il basso"
    ],
    "correct": "D"
  },
  {
    "id": 18,
    "text": "Un flowchart è:",
    "options": [
      "A. utilizzato per illustrare la strutt ura fisica del problema",
      "B. Utilizzato per illustrare la struttura logica deò problema",
      "C. utilizzato per rappresentare solo i cicli",
      "D. Utilizzato per rappresentare solo sequenze e cicli"
    ],
    "correct": "B"
  },
  {
    "id": 19,
    "text": "Coding vuol dire:",
    "options": [
      "A. Scrivere il programma in pseudo codice",
      "B. scrivere il programma in un linguaggio formale",
      "C. Scrivere il programma in un linguaggio di programmazione"
    ],
    "correct": "C"
  },
  {
    "id": 20,
    "text": "Quali sono le tipologie di errori di programmazione:",
    "options": [
      "A. Sintattici, fisici, logici",
      "B. Sintattici, logici, semantici",
      "C. Logici, semantici, fisici",
      "D. Sintattici, run -time, logici"
    ],
    "correct": "D"
  },
  {
    "id": 21,
    "text": "In un flowchart i l Terminal è rappresentato da:",
    "options": [
      "A. Rombo",
      "B. Rettangolo",
      "C. Rettangolo arrotondato",
      "D. Parallelogramma"
    ],
    "correct": "C"
  },
  {
    "id": 22,
    "text": "In un flowchart le operazioni di Input/Output sono rappresentate da:",
    "options": [
      "A. Rombo",
      "B. Rettangolo",
      "C. Rettangolo arrotondato",
      "D. Parallelogramma"
    ],
    "correct": "D"
  },
  {
    "id": 23,
    "text": "In un flowchart i processi sono rappresentati da:",
    "options": [
      "A. Rombo",
      "B. Rettangolo",
      "C. Rettangolo arrotondato",
      "D. Parallelogramma"
    ],
    "correct": "B"
  },
  {
    "id": 24,
    "text": "In un flowchart l a struttura di tipo Decision rappresenta:",
    "options": [
      "A. Una serie di azioni eseguite in sequenza",
      "B. Una serie di azioni eseguite con un controllo decisionale (si/no)",
      "C. Una serie di azioni eseguite una o più volte"
    ],
    "correct": ""
  },
  {
    "id": 25,
    "text": "In un flowchart la struttura di tipo Repetition rappresenta:",
    "options": [
      "A. Una serie di azioni eseguite in sequenza",
      "B. Una serie di azioni eseguite con un controllo decisionale (si/no)",
      "C. Una serie di azioni eseguite una o più volte",
      "D. Una serie di azioni eseguite due o tre volte"
    ],
    "correct": "C"
  },
  {
    "id": 26,
    "text": "L’azione eseguita da una struttura «repetition»:",
    "options": [
      "A. Non deve causare la terminazione del ciclo"
    ],
    "correct": "D"
  },
  {
    "id": 27,
    "text": "La definizione \"l’insieme di regole formali per la scrittura di parole in un linguaggio\" si riferisce a:",
    "options": [
      "A. Lessico",
      "B. Sintassi",
      "C. Semantica",
      "D. Linguaggio"
    ],
    "correct": "A"
  },
  {
    "id": 28,
    "text": "La definizione \"l’insieme di regole formali per la scrittura di fra si in un linguaggio, che stabiliscono cioè la  grammatica del linguaggio stesso\" si riferisce a:",
    "options": [
      "A. Lessico",
      "B. Sintassi",
      "C. Semantica",
      "D. Linguaggio"
    ],
    "correct": "B"
  },
  {
    "id": 29,
    "text": "La definizione \"ll’insieme dei significati da attribuire a lle frasi (sintatticamente corrette) costruite nel linguaggio\"  si riferisce a:",
    "options": [
      "A. Lessico",
      "B. Sintassi",
      "C. Semantica",
      "D. Linguaggio"
    ],
    "correct": "C"
  },
  {
    "id": 30,
    "text": "Il calcolatore comprende solo:",
    "options": [
      "A. Linguaggi ad alto livello",
      "B. Lingua ingle se",
      "C. Lingua italiana",
      "D. Linguaggio binario"
    ],
    "correct": "D"
  },
  {
    "id": 31,
    "text": "La programmazione a basso livello consente di sviluppare programmi molto efficienti su uno specifico sistema  hardware/software, ed è:",
    "options": [
      "A. Semplice e comprensibil e",
      "C. Semplice ma poco intuitiva"
    ],
    "correct": "B"
  },
  {
    "id": 32,
    "text": "Consentono di trattare oggetti complessi senza doversi preoccupare dei dettagli della macchina sulla quale il   DO NOT PAY FOR THIS DOCUMENT - FREE DOCUMENT - NO DOCSITY - NON PAGARE PER QUESTO DOCUMENTO   DO NOT PAY FOR THIS DOCUMENT - FREE DOCUMENT - NO DOCSITY - NON PAGARE PER QUESTO DOCUMENTO  programma viene eseguito…:",
    "options": [
      "A. Linguaggi a basso livello",
      "B. Linguaggi ad alto livello",
      "C. Sia i linguaggi ad alto livello che quelli a basso livello",
      "D. Linguaggi assembly"
    ],
    "correct": "B"
  },
  {
    "id": 33,
    "text": "\"Facilità nell’effettuare modifich e di tipo correttivo, perfettivo, evolutivo e adattivo\". Ci riferiamo a:",
    "options": [
      "A. Portabilità",
      "B. Leggibilità",
      "C. Manutenibilità"
    ],
    "correct": "C"
  },
  {
    "id": 34,
    "text": "\"I programmi scritti per un calcolatore possono essere utilizzati s u qualsiasi altro calcolatore, previa  ricompilazione\". Ci riferiamo a:",
    "options": [
      "A. Portabilità",
      "B. Leggibilità",
      "C. Manutenibilità"
    ],
    "correct": "A"
  },
  {
    "id": 35,
    "text": "\"La relativa similitudine con i linguaggi naturali rende i programmi più semplici, non solo da scrivere, ma anche da  leggere\". Ci riferiamo a:",
    "options": [
      "A. Portabilità",
      "B. Leggibilità",
      "C. Manutenibilità"
    ],
    "correct": "B"
  },
  {
    "id": 36,
    "text": "Il modello computazionale è basato sul cambiamento di stato della  memoria della macchina...:",
    "options": [
      "A. Nei linguaggi dichiarativi",
      "B. Sia nei linguaggi dichiarativi che imperativi",
      "C. Nei linguaggi imperativi",
      "D. Nei linguaggi dichiarativi o nei linguaggi imperativi, a seconda dei casi"
    ],
    "correct": "C"
  },
  {
    "id": 37,
    "text": "ANSI C nasce nel:",
    "options": [
      "A. 1978",
      "B. 1980",
      "C. 1989",
      "D. 1990"
    ],
    "correct": "C"
  },
  {
    "id": 38,
    "text": "Il linguaggio C:",
    "options": [
      "A. Ha solo caratteristiche di alto livello",
      "B. Ha solo caratteristiche di basso livello",
      "C. Ha sia carat teristiche di alto che di basso livello",
      "D. Non ha caratteristiche di alto e basso livello"
    ],
    "correct": "C"
  },
  {
    "id": 39,
    "text": "I tipi di errore Error e Warning…:",
    "options": [
      "A. Sono la stessa cosa",
      "B. Sono due cose diverse"
    ],
    "correct": "B"
  },
  {
    "id": 40,
    "text": "Nel linguaggio C, i caratteri maiuscoli e minuscoli:",
    "options": [
      "B. Non si possono usare",
      "C. Sono uguali o  diversi a seconda del blocco di istruzioni"
    ],
    "correct": "D"
  },
  {
    "id": 41,
    "text": "Quando una istruzione è costituita dal solo carattere ';':",
    "options": [
      "A. E' considerata istruzione nulla",
      "B. E' equivalente ad una inizializzazione",
      "C. E' un commento",
      "D. Viene segnalato un Error"
    ],
    "correct": "A"
  },
  {
    "id": 42,
    "text": "L'inizio di un commento è caratterizzato dalla coppia di caratteri:",
    "options": [
      "A. */",
      "B. /*",
      "D. /**"
    ],
    "correct": "B"
  },
  {
    "id": 43,
    "text": "Un blocco di  codice è un insieme di istruzioni racchiuso tra parentesi:",
    "options": [
      "A. Tonde",
      "B. Quadre",
      "D. Graffe"
    ],
    "correct": "D"
  },
  {
    "id": 44,
    "text": "Se il blocco di codice è costituito da una sola istruzione:",
    "options": [
      "A. Si usano parentesi tonde al posto delle parentesi graffe",
      "B. Le parentesi graffe vengono normalmente omesse",
      "C. Si usano parentesi quadre al posto delle parentesi graffe",
      "D. Si usa doppia parentesi graffa"
    ],
    "correct": "B"
  },
  {
    "id": 45,
    "text": "L'indentazione è u tile per:",
    "options": [
      "B. Eseguire il codice più velocemente",
      "C. Occupare meno spazio in memoria",
      "D. Ottenere un eseguibile in automatico"
    ],
    "correct": "A"
  },
  {
    "id": 46,
    "text": "Le istruzioni in un programma C terminano sempre con… :",
    "options": [
      "A. ;",
      "B. ::",
      "C. ;;",
      "D. ()"
    ],
    "correct": "A"
  },
  {
    "id": 47,
    "text": "Le direttive come #include, #define vengono elaborati da:",
    "options": [
      "B. Linker",
      "C. Preprocessore",
      "D. Linker e compilatore"
    ],
    "correct": "C"
  },
  {
    "id": 48,
    "text": "Traduce il codice C in linguaggio macchina…:",
    "options": [
      "B. Linker",
      "C. Preprocessore",
      "D. Linker e compilatore"
    ],
    "correct": "A"
  },
  {
    "id": 49,
    "text": "I tipi di errore Error e Warning…:",
    "options": [
      "A. Sono la stessa cosa",
      "B. Sono due cose div erse"
    ],
    "correct": "B"
  },
  {
    "id": 50,
    "text": "Nel linguaggio C, i caratteri maiuscoli e minuscoli:",
    "options": [
      "B. Non si possono usare",
      "C. Sono uguali o diversi a seconda del blocco di istruzioni"
    ],
    "correct": "D"
  },
  {
    "id": 51,
    "text": "Se decidiamo di scrivere un programma con un qualsi asi editor di testo, per poter vedere il risultato dobbiamo  salvare il file con estensione:",
    "options": [
      "A. .txt",
      "B. .doc",
      "C. .c",
      "D. .xls"
    ],
    "correct": "C"
  },
  {
    "id": 52,
    "text": "L’assembler è incaricato di creare il codice oggetto salvandolo in un file…:",
    "options": [],
    "correct": "D"
  },
  {
    "id": 53,
    "text": "GCC è un:",
    "options": [
      "A. Ecitor di testo",
      "D. Linguaggio di programmazione"
    ],
    "correct": "C"
  },
  {
    "id": 54,
    "text": "Assembla in un unico file eseguibile i file oggetto prodotti da diversi file sorgente e le librerie:",
    "options": [
      "B. Linker",
      "C. Preprocessore",
      "D. Linker e compilatore"
    ],
    "correct": "B"
  },
  {
    "id": 55,
    "text": "Sono errori sintattici, che impediscono la generazione del codice eseguibile:",
    "options": [
      "A. Warning",
      "B. Error",
      "C. Sia Error che Warning",
      "D. Warning nella maggior parte dei casi"
    ],
    "correct": "B"
  },
  {
    "id": 56,
    "text": "So no errori non sintattici che non impediscono la generazione del codice eseguibile:",
    "options": [
      "A. Warning",
      "B. Error",
      "C. Sia Error che Warning",
      "D. Warning nella maggior parte dei casi"
    ],
    "correct": "A"
  },
  {
    "id": 57,
    "text": "Una r iga di commento inizia con:",
    "options": [
      "A. \\\\",
      "B. //",
      "C. **",
      "D. /?"
    ],
    "correct": "B"
  },
  {
    "id": 58,
    "text": "Un commento multilinea termina con:",
    "options": [
      "A. \\\\",
      "B. //",
      "C. */",
      "D. /*"
    ],
    "correct": "C"
  },
  {
    "id": 59,
    "text": "Le istruzioni di include per il preprocessore in iziano con:",
    "options": [
      "A. #",
      "B. \"",
      "C. */",
      "D. ("
    ],
    "correct": "A"
  },
  {
    "id": 60,
    "text": "Un blocco e' racchiuso da parentesi:",
    "options": [
      "A. graffe",
      "B. tonde",
      "C. quadrate",
      "D. angolari"
    ],
    "correct": "A"
  },
  {
    "id": 61,
    "text": "Il termine void, argomento della funzione main, e' rac chiuso fra parentesi:",
    "options": [
      "A. graffe",
      "B. tonde",
      "C. quadrate",
      "D. angolari"
    ],
    "correct": "B"
  },
  {
    "id": 62,
    "text": "Il messaggio da stampare all'interno della funzione printf va racchiuso fra:",
    "options": [
      "A. \"",
      "B. \\",
      "D. ["
    ],
    "correct": "A"
  },
  {
    "id": 63,
    "text": "Ogni istruzione deve terminare con:",
    "options": [
      "A. punto",
      "B. virgola",
      "C. due punti",
      "D. punto e virgola"
    ],
    "correct": "D"
  },
  {
    "id": 64,
    "text": "La sequenza di escape \\ n:",
    "options": [
      "A. posiziona il cursore alla riga successiva",
      "B. produce un suono o un allarme",
      "C. inserisce un carattere di backslash",
      "D. Inserisce un carattere di backslash seguito dalla lettera n"
    ],
    "correct": "A"
  },
  {
    "id": 65,
    "text": "La sequenza di escape \\ a:",
    "options": [
      "A. posiziona il cursore alla riga successiva",
      "B. produce un suono o un allarme",
      "C. inserisce un carattere di backslash",
      "D. inserisce un carattere di backslash seguito dalla lettera a"
    ],
    "correct": "B"
  },
  {
    "id": 66,
    "text": "Stdio.h contiene:",
    "options": [
      "A. l'istruzione main",
      "B. il linker",
      "C. l'eseguibile",
      "D. l'istruzione printf"
    ],
    "correct": "D"
  },
  {
    "id": 67,
    "text": "Chiedere un numero all'utente è una operazione di:",
    "options": [
      "A. input",
      "B. output",
      "C. ela borazione",
      "D. input e output"
    ],
    "correct": "A"
  },
  {
    "id": 68,
    "text": "Le variabili devono essere:",
    "options": [
      "A. definite con un nome e un tipo di dato",
      "B. definite con il solo nome",
      "C. definite in un punto qualsiasi del programma",
      "D. usate prima della definizione"
    ],
    "correct": "A"
  },
  {
    "id": 69,
    "text": "Il nome di una variabile:",
    "options": [
      "A. È a discrezione del compilatore",
      "B. deve includere trattini \"_\"",
      "C. È sensibile all'uso del carattere",
      "D. inizia con una cifra"
    ],
    "correct": "C"
  },
  {
    "id": 70,
    "text": "La funzione scanf:",
    "options": [
      "A. scrive sullo standard outpu t",
      "B. include stringhe di controllo di formato",
      "C. puo' essere priva di argomenti",
      "D. stampa sullo schermo un messaggio"
    ],
    "correct": "B"
  },
  {
    "id": 71,
    "text": "Nella funzione scanf, una variabile deve essere:",
    "options": [
      "A. preceduta da &",
      "B. seguita da &",
      "C. prec eduta da %",
      "D. seguita da %"
    ],
    "correct": "A"
  },
  {
    "id": 72,
    "text": "La stringa di controllo di formato per un integer include la lettera:",
    "options": [
      "A. f",
      "B. d",
      "D. p"
    ],
    "correct": "B"
  },
  {
    "id": 73,
    "text": "L'operatore di assegnazione è:",
    "options": [
      "A. %",
      "B. \"",
      "C. ==",
      "D. ="
    ],
    "correct": "D"
  },
  {
    "id": 74,
    "text": "In C, i calcoli possono essere eseguiti:",
    "options": [
      "A. nell'istruzione printf, all'esterno di virgolette \" \"",
      "B. a sinistra dell'operatore di assegnazione",
      "C. nell'istruzione scanf, all'interno di virgolette \"  \"",
      "D. nell'istruzione printf, all'interno di virgolette \" \""
    ],
    "correct": "A"
  },
  {
    "id": 75,
    "text": "È possibile assegnare un valore a una variabile:",
    "options": [
      "A. nella sua definizione",
      "B. prima delle istruzioni al preprocessore",
      "C. senza terminare l'istruzione con il punto e virgola",
      "D. solo se diverso da zero"
    ],
    "correct": "A"
  },
  {
    "id": 76,
    "text": "L'istruzione: int a1, a2; è:",
    "options": [
      "A. errata, non si possono definire due variabili nella stessa istruzione"
    ],
    "correct": ""
  },
  {
    "id": 77,
    "text": "C. corretta   D. er rata, non si possono separare due variabili con virgola     Answer: C   Section: Le iabili        DO NOT PAY FOR THIS DOCUMENT - FREE DOCUMENT - NO DOCSITY - NON PAGARE PER QUESTO DOCUMENTO   DO NOT PAY FOR THIS DOCUMENT - FREE DOCUMENT - NO DOCSITY - NON PAGARE PER QUESTO DOCUMENTO  Capitolo 10: Aritmetica in C",
    "options": [
      "C. corretta",
      "D. er rata, non si possono separare due variabili con virgola"
    ],
    "correct": "C"
  },
  {
    "id": 78,
    "text": "L'istruzione scanf( '%d', &var ); :",
    "options": [
      "A. sovrascrive la locazione di memoria di var",
      "B. legge la locazione di memoria di var",
      "C. scrive nel la locazione di memoria di var solo se vuota",
      "D. stampa il contenuto della locazione di memoria"
    ],
    "correct": "A"
  },
  {
    "id": 79,
    "text": "L'istruzione a = b; è:",
    "options": [
      "A. distruttiva per la variabile a",
      "B. non distruttiva per la variabile a",
      "C. distrutt iva per la variabile b",
      "D. non distruttiva per le variabili a e b"
    ],
    "correct": "A"
  },
  {
    "id": 80,
    "text": "Il segno di percentuale (%) indica l'operatore di:",
    "options": [
      "A. modulo",
      "B. esponente",
      "C. resto",
      "D. decimale"
    ],
    "correct": "C"
  },
  {
    "id": 81,
    "text": "La divisione intera 22 / 3 restituisce:",
    "options": [
      "A. 7",
      "B. 1",
      "C. 7,333",
      "D. 3"
    ],
    "correct": "A"
  },
  {
    "id": 82,
    "text": "Gli operatori del C sono calcolati:",
    "options": [
      "A. da sinistra a destra",
      "B. da destra a sinistra",
      "C. a seconda della loro assoc iatività",
      "D. in ordine di definizione"
    ],
    "correct": "C"
  },
  {
    "id": 83,
    "text": "I calcoli sono normalmente eseguiti da istruzioni di:",
    "options": [
      "A. assegnazione",
      "B. definizione",
      "D. controllo"
    ],
    "correct": "A"
  },
  {
    "id": 84,
    "text": "Il valore dell'istr uzione x = 33 -  3 * ( 3 + 3 * ( 3 ) / 3 -  3)); corrisponde a:",
    "options": [
      "A. 27",
      "B. errore per parentesi ridondanti",
      "C. 24",
      "D. 90"
    ],
    "correct": "B"
  },
  {
    "id": 85,
    "text": "Le regole di precedenza indicano che:",
    "options": [
      "A. operatore di moltiplicazione ha la precedenza su oper atore di resto",
      "B. operatore di resto ha la precedenza su operatore di moltiplicazione",
      "C. moltiplicazione ha la precedenza sulle operazioni all'interno di parentesi annidate",
      "D. l'operatore di resto ha la precedenza sull'uguale"
    ],
    "correct": "D"
  },
  {
    "id": 86,
    "text": "In caso di parentesi annidate:",
    "options": [
      "A. gli operatori nella coppia di parentesi più interne sono applicati per primi",
      "B. gli operatori nella coppia di parentesi più interne sono applicati per ultimi",
      "C. gli operatori di moltiplicazione sono applicati per primi",
      "D. gli operatori di somma sono applicati per primi"
    ],
    "correct": "A"
  },
  {
    "id": 87,
    "text": "Per scrivere su una stessa linea i valori 5 e 2 si usa:",
    "options": [
      "A. printf( '10/2, 2\\ n' );",
      "B. scanf( '%d%d \\n', 10/2, 2 );",
      "C. x=10/5; printf('5, %d \\n', & x);",
      "D. printf('%d,%d \\n', 10/2, 10/5);"
    ],
    "correct": "D"
  },
  {
    "id": 88,
    "text": "L'operatore diverso si indica in C con:",
    "options": [
      "A. !=",
      "B. < >",
      "C. ==",
      "D. not"
    ],
    "correct": "A"
  },
  {
    "id": 89,
    "text": "L'operatore minore o uguale si indica in C con:",
    "options": [
      "A. < <",
      "B. < =",
      "C. = <",
      "D. ≤"
    ],
    "correct": "B"
  },
  {
    "id": 90,
    "text": "L'operatore di uguaglianza si indica in C con:",
    "options": [
      "A. =",
      "B. ==",
      "C. :=",
      "D. =:"
    ],
    "correct": "B"
  },
  {
    "id": 91,
    "text": "Gli operatori relazionali:",
    "options": [
      "A. hanno un livello di precedenza più alto degli operatori di uguaglianza",
      "B. hanno un livello di precedenza più basso degli operatori di uguaglianza",
      "C. hanno un livello di precedenza uguale agli operatori di assegna zione",
      "D. hanno un livello di precedenza uguale agli operatori di uguaglianza"
    ],
    "correct": "A"
  },
  {
    "id": 92,
    "text": "Migliora la leggibilità del programma:",
    "options": [
      "A. eliminare righe vuote sopra l'istruzione if",
      "B. eliminare righe vuote sotto  l'istruzione if",
      "C. indentare la parentesi graffa di fine istruzione if",
      "D. indentare il corpo di ognuna delle istruzioni if"
    ],
    "correct": "D"
  },
  {
    "id": 93,
    "text": "Nel corpo di un'istruzione if:",
    "options": [
      "A. è corretto spezzare gli identificatori",
      "B. si devono evitare le parentesi graffe se è inserita una sola istruzione",
      "D. si può inserire una sola istruzione di assegnazione"
    ],
    "correct": "C"
  },
  {
    "id": 94,
    "text": "L'associatività da destra a sinistra si ha per l'operato re:",
    "options": [
      "A. ()",
      "B. *",
      "C. =",
      "D. :="
    ],
    "correct": "C"
  },
  {
    "id": 95,
    "text": "L'istruzione puts:",
    "options": [
      "A. equivale a printf",
      "B. equivale a scanf",
      "C. stampa testo e determina un ritorno a capo",
      "D. migliora la sicurezza per istruzioni di output con argomenti multipli"
    ],
    "correct": "C"
  },
  {
    "id": 96,
    "text": "L'istruzione printf( '%s', 'Welcome' ); è:",
    "options": [
      "A. stampa Welcome e non va a capo",
      "B. stampa Welcome e va a capo",
      "C. errata a causa dell'uso di %s",
      "D. errata a causa della mancanza di /n"
    ],
    "correct": "A"
  },
  {
    "id": 97,
    "text": "Le parole chi ave:",
    "options": [
      "A. sono usate per istruzioni di ricerca in locazioni di memoria",
      "B. non devono essere usate come nomi delle variabili",
      "C. includono printf e scanf"
    ],
    "correct": "B"
  },
  {
    "id": 98,
    "text": "Una procedura per risolvere un problema che consta in un insieme di azioni da eseguire e in un dato ordine in cui  esse vanno eseguite è chiamata:",
    "options": [
      "A. programmazione strutturata",
      "B. algoritmo",
      "C. struttura sequenziale  strutturata",
      "D. struttura di controllo"
    ],
    "correct": "B"
  },
  {
    "id": 99,
    "text": "Lo pseudocodice è costituito solamente da:",
    "options": [
      "A. istruzioni di decisione e azione",
      "C. azioni sequenziali",
      "D. da dichiarazioni di variabili"
    ],
    "correct": "A"
  },
  {
    "id": 100,
    "text": "I programmi in pseudocodice:",
    "options": [
      "A. sono eseguiti dal preprocessore",
      "B. sono eseguiti dal compilatore",
      "C. non sono eseguiti al computer",
      "D. sono compilati dal linker"
    ],
    "correct": "C"
  },
  {
    "id": 101,
    "text": "Un diagramma di flusso è:",
    "options": [
      "A. una rappre sentazione in linguaggio formale di un algoritmo",
      "B. una rappresentazione grafica di un algoritmo",
      "C. una rappresentazione matematica di un algoritmo",
      "D. una rappresentazione in pseudocodice di un algoritmo"
    ],
    "correct": "B"
  },
  {
    "id": 102,
    "text": "Nei diag rammi di flusso, porzioni omesse vengono rappresentate da:",
    "options": [
      "A. linee di flusso",
      "B. rettangoli arrotondati",
      "C. rettangoli",
      "D. cerchietti"
    ],
    "correct": "D"
  },
  {
    "id": 103,
    "text": "Nei diagrammi di flusso, il simbolo di decisione è rappresentato da:",
    "options": [
      "A. un rombo  con due linee di flusso che emergono da esso",
      "C. un rettangolo con due linee di flusso che emergono da esso",
      "D. un rettangolo arrotondato con due linee di flusso che emergono da esso"
    ],
    "correct": "A"
  },
  {
    "id": 104,
    "text": "Se l'istruzione successiva da eseguire può essere diversa dalla successiva in sequenza si parla di esecuzione con:",
    "options": [
      "A. trasferimento del controllo",
      "B. strutture di controllo sequenziale",
      "C. strutture di controllo iterative",
      "D. strutture di  controllo di selezione"
    ],
    "correct": "A"
  },
  {
    "id": 105,
    "text": "L'istruzione di selezione singola è:",
    "options": [
      "A. if",
      "B. if..else",
      "C. switch",
      "D. while"
    ],
    "correct": "A"
  },
  {
    "id": 106,
    "text": "La struttura di iterazione consente di eseguire azioni finché:",
    "options": [
      "A. non si incontra una istruzione di selezione",
      "B. non si incontra una istruzione di sequenza",
      "C. non si incontra una istruzione di iterazione",
      "D. non si soddisfano determinate condizioni"
    ],
    "correct": "D"
  },
  {
    "id": 107,
    "text": "Le decisioni nell'istruz ione if:",
    "options": [
      "A. devono basarsi su espressioni che abbiano valore zero",
      "B. possono basarsi su qualsiasi espressione",
      "C. devono basarsi su condizioni contenenti il >=",
      "D. devono basarsi su condizioni contenenti =="
    ],
    "correct": "B"
  },
  {
    "id": 108,
    "text": "Nell'istruzione if...else, se la condizione nell'if è vera:",
    "options": [
      "A. vengono eseguite entrambe le azioni nell'if e nell'else",
      "B. viene eseguita solo l'azione nell'else",
      "C. non viene eseguita l'azione nell'else",
      "D. non v iene eseguita alcuna azione"
    ],
    "correct": "C"
  },
  {
    "id": 109,
    "text": "Il corpo di else:",
    "options": [
      "A. richiede sempre parentesi graffe",
      "B. richiede sempre parentesi tonde",
      "C. non richiede sempre parentesi graffe",
      "D. richiede sempre parentesi angolari"
    ],
    "correct": "C"
  },
  {
    "id": 110,
    "text": "L'operatore condizionale si indica con:",
    "options": [
      "A. :?",
      "B. ?",
      "C. :=",
      "D. ?:"
    ],
    "correct": "D"
  },
  {
    "id": 111,
    "text": "Nell'espressione condizionale, con operatore condizionale, il secondo operando è:",
    "options": [
      "A. l'espressione se la condizion e è falsa",
      "B. l'espressione se la condizione è vera",
      "C. la condizione",
      "D. privo di significato"
    ],
    "correct": "B"
  },
  {
    "id": 112,
    "text": "In questa istruzione var > 10 ? puts( 'Lost' ) ?: puts( 'Win' ); sono presenti:",
    "options": [
      "A. 0 errori",
      "B. 1 errore",
      "C. 2 error i",
      "D. 3 errori"
    ],
    "correct": "B"
  },
  {
    "id": 113,
    "text": "In questa istruzione var > 10 ? puts( 'Lost' ); : puts( 'Win' ); sono presenti:",
    "options": [
      "A. 0 errori",
      "B. 1 errore",
      "D. 3 errori"
    ],
    "correct": "B"
  },
  {
    "id": 114,
    "text": "Nelle istruzio ni annidate if...else:",
    "options": [
      "A. tutte le condizioni vere vengono eseguite",
      "B. solo l'ultima condizione vera viene eseguita",
      "C. solo la prima condizione vera viene eseguita",
      "D. nessuna condizione vera viene eseguita"
    ],
    "correct": "C"
  },
  {
    "id": 115,
    "text": "La riga di codice else if ( x >= 24 ); {x++;} conteine:",
    "options": [
      "A. 0 errori",
      "B. 1 errore",
      "C. 2 errori",
      "D. 3 errori"
    ],
    "correct": "B"
  },
  {
    "id": 116,
    "text": "Un errore di sintassi:",
    "options": [
      "A. è individuato dal compilatore",
      "B. all'esecuzione fa sì che il programma fallisca",
      "C. all'esecuzione fa sì che il programma termini prematuramente",
      "D. all'esecuzione produce risultati non corretti"
    ],
    "correct": "A"
  },
  {
    "id": 117,
    "text": "L'istruzione vuota è rappresentata da:",
    "options": [
      "A. ;",
      "B. :",
      "C. ()",
      "D. []"
    ],
    "correct": "A"
  },
  {
    "id": 118,
    "text": "L'istruzione while:",
    "options": [
      "A. è una istruzione di definizione",
      "B. è una istruzione di iterazione",
      "C. è una istruzione di dichiarazione",
      "D. è un a istruzione di assegnamento"
    ],
    "correct": "B"
  },
  {
    "id": 119,
    "text": "Il ciclo while termina:",
    "options": [
      "A. quando la condizione diventa falsa",
      "B. quando la condizione diventa vera",
      "C. mai",
      "D. solo in caso errore"
    ],
    "correct": "A"
  },
  {
    "id": 120,
    "text": "Il corpo dell'is truzione while:",
    "options": [
      "A. deve essere un'istruzione singola",
      "B. deve essere un'istruzione composta",
      "C. non deve contenere istruzioni",
      "D. può essere un'istruzione singola o un'istruzione composta"
    ],
    "correct": "D"
  },
  {
    "id": 121,
    "text": "Quando l'iterazione while termina:",
    "options": [
      "A. viene eseguita l'iterazione un'ultima volta",
      "B. viene eseguita la prima istruzione dopo la struttura di iterazione",
      "C. termina il programma",
      "D. viene eseguita l'ultima istruzione prima della struttura di iterazione"
    ],
    "correct": "B"
  },
  {
    "id": 122,
    "text": "Il diagramma di flusso dell'iterazione while si compone di:",
    "options": [
      "A. un rombo e di un rettangolo sull'uscita vera",
      "B. un rettangolo seguito sequenzialmente da un rombo",
      "C. un rombo seguito sequenzialmente da un rettangolo",
      "D. un rombo e di un rettangolo sull'uscita falsa"
    ],
    "correct": "A"
  },
  {
    "id": 123,
    "text": "Dato int n=1, il programma che stampa come ultimo numero il valore 9 è:",
    "options": [
      "A. while ( n < 9 ) { printf('%d ', n++); }",
      "B. while ( n < 9 ) { printf('%d ', n); }",
      "D. while ( n <= 9 ) { printf('%d ', n++); }"
    ],
    "correct": "D"
  },
  {
    "id": 124,
    "text": "Dato int x=0, il programma che stampa come ultimo numero il valore 7 è:",
    "options": [
      "A. while ( x < 7 ) {x++;} printf('%d', x);",
      "B. while ( x < 7 ) {x++;} printf('%d', ++x);",
      "C. while ( x < 7 ) {x;} printf('%d', x);",
      "D. while ( x <= 7 ) {x++;} printf('%d');"
    ],
    "correct": "A"
  },
  {
    "id": 125,
    "text": "Dato int x=1; l'istruzione while (x < 9); restituisce:",
    "options": [
      "A. errore di compilazione",
      "B. ciclo infinito",
      "C. stampa 9",
      "D. stampa 8"
    ],
    "correct": "B"
  },
  {
    "id": 126,
    "text": "Dato int x = - 1; il codice while (x < 99){x++;} esegue:",
    "options": [
      "A. 98 iterazioni",
      "B. 99 iterazioni",
      "C. 100 iterazioni",
      "D. 101 iterazioni"
    ],
    "correct": "C"
  },
  {
    "id": 127,
    "text": "Dato int x=1; l'istruzione while (x < 1) {x++;} è:",
    "options": [
      "A. corretta, non ese gue alcuna iterazione",
      "B. corretta, esegue due iterazioni",
      "C. corretta, esegue una iterazione",
      "D. errata"
    ],
    "correct": "A"
  },
  {
    "id": 128,
    "text": "L'iterazione controllata da contatore è una iterazione:",
    "options": [
      "A. definita",
      "B. indefinita",
      "C. di inizializzazione",
      "D. di primo affinamento"
    ],
    "correct": "A"
  },
  {
    "id": 129,
    "text": "Nell'ierazione controllata da contatore, il contatore specifica il numero:",
    "options": [
      "A. della variabile sentinella",
      "B. di locazioni  di memoria utilizzate dall'iterazione",
      "C. di volte in cui l'istruzione printf deve essere eseguita",
      "D. di volte in cui le istruzioni dell'iterazione deveno essere eseguite"
    ],
    "correct": "D"
  },
  {
    "id": 130,
    "text": "Nelle iterazioni definite, il numero di esecuzioni dell'iterazione:",
    "options": [
      "A. È zero",
      "B. non si conosce prima che il ciclo inizi l'esecuzione",
      "C. lo determina l'utente durante l'esecuzione",
      "D. si conosce prima che il ciclo inizi l'esecuzione"
    ],
    "correct": "D"
  },
  {
    "id": 131,
    "text": "Per un contatore da 0 a 20000, la variabile piu' appropriata e' di tipo:",
    "options": [
      "A. int",
      "B. unsigned int",
      "C. float",
      "D. double"
    ],
    "correct": "B"
  },
  {
    "id": 132,
    "text": "Se un contatore non viene inizializzato :",
    "options": [
      "A. si verifica un errore logico",
      "B. si verifica un errore di compilazione",
      "C. si verifica un errore al linker",
      "D. non si verificano errori"
    ],
    "correct": "A"
  },
  {
    "id": 133,
    "text": "Se un contatore non viene inizializzato:",
    "options": [
      "A. il programma lo inizializza automaticamente a la valore 0",
      "B. il programma lo inizializza automaticamente a la valore 1",
      "D. l'esecuzione del pr ogramma non viene avviata"
    ],
    "correct": "C"
  },
  {
    "id": 134,
    "text": "La divisione intera 817/10 produce:",
    "options": [
      "A. 81.7",
      "B. 81,7",
      "C. 81",
      "D. 82"
    ],
    "correct": "C"
  },
  {
    "id": 135,
    "text": "Se un contatore int viene incrementato di 1 oltre il suo limito superiore, si ottiene:",
    "options": [
      "A. errore di compilazione",
      "B. come successivo valore un numero negativo",
      "C. come successivo valore lo zero",
      "D. come successivo valore un numero casuale relativo alla locazione di memoria utili zzata"
    ],
    "correct": "B"
  },
  {
    "id": 136,
    "text": "Se un contatore unsigned int viene incrementato di 1 oltre il suo limito superiore, si ottiene:",
    "options": [
      "A. errore di compilazione",
      "B. come successivo valore un numero negativo",
      "C. come su ccessivo valore lo zero",
      "D. come successivo valore un numero casuale relativo alla locazione di memoria utilizzata"
    ],
    "correct": "C"
  },
  {
    "id": 137,
    "text": "Una buona pratica di programmazione prevede di:",
    "options": [
      "A. non inizializzare  i contatori e i totali per evitare l'occupazione inutile di locazioni di memoria",
      "B. inizializzare solo i contatori",
      "C. inizializzare solo i totali",
      "D. inizializzare tutti i contatori e i totali"
    ],
    "correct": "D"
  },
  {
    "id": 138,
    "text": "L'iterazione controllata da sentinella è una iterazione:",
    "options": [
      "A. definita",
      "B. indefinita",
      "C. di inizializzazione",
      "D. di primo affinamento"
    ],
    "correct": "B"
  },
  {
    "id": 139,
    "text": "Il valore sentinella viene utilizzato per indicare:",
    "options": [
      "A. che è stato inserito l'ultimo valore dell'iterazione",
      "B. che è stato inserito il primo valore dell'iterazione",
      "C. che è stato raggiunto il valore massimo del contatore",
      "D. che è stato inizializ zato il contatore"
    ],
    "correct": "A"
  },
  {
    "id": 140,
    "text": "Nelle iterazioni indefinite, il numero di esecuzioni dell'iterazione:",
    "options": [
      "A. È zero",
      "B. non si conosce prima che il ciclo inizi l'esecuzione",
      "C. È uno",
      "D. si conosce prim a che il ciclo inizi l'esecuzione"
    ],
    "correct": "B"
  },
  {
    "id": 141,
    "text": "Per un'iterazione che acquisisce l'età dei componenti di una famiglia, il valore sentinella appropriato è:",
    "options": [
      "A. 0.5",
      "B. -1",
      "C. 100",
      "D. 1"
    ],
    "correct": "B"
  },
  {
    "id": 142,
    "text": "L'affinamento graduale top -down:",
    "options": [
      "A. È una tecnica utile allo sviluppo di programmi ben strutturati",
      "B. È una tecnica utile allo sviluppo di programmi non strutturati"
    ],
    "correct": "A"
  },
  {
    "id": 143,
    "text": "A livello top, nell'affinamento graduale top -down, si ha:",
    "options": [
      "B. un set di tre istruzioni di pseudocodice",
      "D. un'istruzione singola di pseudocodice"
    ],
    "correct": "D"
  },
  {
    "id": 144,
    "text": "A livello top, nell'affinamento graduale top -down, si definisce:",
    "options": [
      "A. la definizione delle variabili del programma",
      "B. la funzi one iniziale del programma",
      "C. la funzione complessiva del programma",
      "D. la computazione del risultato del programma"
    ],
    "correct": "C"
  },
  {
    "id": 145,
    "text": "Il processo di affinamento graduale top -down termina quando:",
    "options": [
      "A. lo pseudocodice definis ce il programma con sufficiente dettaglio",
      "C. lo pseudocodice raggiunge le dieci righe"
    ],
    "correct": "A"
  },
  {
    "id": 146,
    "text": "Un tent ativo di dividere per zero provoca:",
    "options": [
      "A. la stampa di un messaggio di buffer overlow",
      "B. un warning",
      "C. un errore logico",
      "D. un errore irreversibile"
    ],
    "correct": "D"
  },
  {
    "id": 147,
    "text": "Molti programmi possono essere divisi logicamente nelle s eguenti fasi:",
    "options": [
      "A. inizializzazione, elaborazione e chiusura",
      "B. elaborazione e chiusura",
      "C. inizializzazione, elaborazione, chiusura e ottimizzazione",
      "D. inizializzazione ed elaborazione"
    ],
    "correct": "A"
  },
  {
    "id": 148,
    "text": "In a = (float) b / c viene creata:",
    "options": [
      "A. una copia permanente in virgola mobile di b",
      "B. una copia temporanea in virgola mobile di b",
      "C. una copia permanente in virgola mobile di a"
    ],
    "correct": ""
  },
  {
    "id": 149,
    "text": "L'operatore cast realizza una:",
    "options": [
      "A. conversione esplicita di tipo di variabile",
      "B. conversione implicita di tipo di variabile",
      "C. conversione esplicita di preincremento",
      "D. conversione esplicita di preincremento"
    ],
    "correct": "A"
  },
  {
    "id": 150,
    "text": "L'struzione printf( '%f', 10/3 ); restituisce:",
    "options": [
      "A. 3.34",
      "B. 3.33",
      "C. 3.333333",
      "D. 3"
    ],
    "correct": "C"
  },
  {
    "id": 151,
    "text": "L'struzione printf( '%.2f', 5/3 ); restituisce:",
    "options": [
      "A. errore",
      "B. 1.66",
      "C. 1.666666",
      "D. 1.67"
    ],
    "correct": "D"
  },
  {
    "id": 152,
    "text": "Eseguendo l'struzione scanf( '%.2f', &a ); si ottiene:",
    "options": [
      "A. l'acquisizione della variabile a come float con due cifr e decimali",
      "B. l'acquisizione della variabile a con sei cifre decimali",
      "C. la stampa della variabile a come float con due cifre decimali",
      "D. errore"
    ],
    "correct": "D"
  },
  {
    "id": 153,
    "text": "L'struzione printf( '%d', c++ ); stampa:",
    "options": [
      "A. il valore di c",
      "B. il valore di c+1",
      "D. il testo 'c++'"
    ],
    "correct": "A"
  },
  {
    "id": 154,
    "text": "L'struzione printf( '%d', -- c ); stampa:",
    "options": [
      "A. il valore di c",
      "B. il valore di c- 1",
      "C. il valore di c- 2"
    ],
    "correct": ""
  },
  {
    "id": 155,
    "text": "Gli operatori di prefisso ++ hanno la precedenza su:",
    "options": [
      "A. operatori di postfisso ++",
      "B. operatori di postfisso --",
      "C. operatori di prefisso --",
      "D. operatore %"
    ],
    "correct": "D"
  },
  {
    "id": 156,
    "text": "L'overflow aritmetico determina:",
    "options": [
      "A. comportamento indefinito",
      "B. errore di compilazione",
      "C. errore al linker",
      "D. nessun problem se le variabili sono di tipo int"
    ],
    "correct": "A"
  },
  {
    "id": 157,
    "text": "La version e sicura di scanf è:",
    "options": [
      "A. fscanf",
      "B. s_scanf",
      "C. scanf_s",
      "D. scanf_sec"
    ],
    "correct": "C"
  },
  {
    "id": 158,
    "text": "For (unsigned int c = 1; c < = 10; ++c) è:",
    "options": [
      "A. corretta",
      "B. errata, serve ',' al posto di ';'",
      "C. errata , serve 'c++' al posto di '++c'",
      "D. errata, serve 'c==1' al posto di 'c=1'"
    ],
    "correct": "A"
  },
  {
    "id": 159,
    "text": "L'istruzione for inizia l'esecuzione:",
    "options": [
      "A. inizializzando la variabile di controllo",
      "B. verificando la condizione di continuazione",
      "C. incrementa ndo/ decrementando il contatore",
      "D. eseguendo printf della variabile contatore"
    ],
    "correct": "A"
  },
  {
    "id": 160,
    "text": "Quando il test di continuazione del ciclo fallisce:",
    "options": [
      "A. Il programma termina con errore",
      "B. Il programma continua un ultima volta ad esegui re il corpo del ciclo for",
      "C. Il programma termina con successo",
      "D. Il programma continua eseguendo la prima istruzione dopo l'istruzione for"
    ],
    "correct": "D"
  },
  {
    "id": 161,
    "text": "Al termine del ciclo for, la variabile di controllo:",
    "options": [
      "A. ha il valore della condizione di continuazione del ciclo",
      "B. riprende il valore iniziale dell'inizializzazione",
      "C. assume valore 1",
      "D. assume valore 0"
    ],
    "correct": "A"
  },
  {
    "id": 162,
    "text": "Le variabili di controllo definite in un'intestazione del for:",
    "options": [
      "A. esistono fino alla f ine della funzione main",
      "B. esistono solo fino al termine del ciclo",
      "C. esistono per tutto il programma",
      "D. esistono solo per la prima iterazione del ciclo"
    ],
    "correct": "B"
  },
  {
    "id": 163,
    "text": "Errori di tipo off -by-one (sfasamento di uno):",
    "options": [
      "A. sono errori di sintassi",
      "B. sono errori logici che determinano un numero errato di cicli for"
    ],
    "correct": "B"
  },
  {
    "id": 164,
    "text": "L'istruzione for (a1 = 1, a2 = 0; a1 < = 10; ++a1, ++a2) è:",
    "options": [
      "A. corretta",
      "B. errata per la doppia inizializzazione",
      "C. errata per il doppio incremento",
      "D. errata per l'uso del virgola"
    ],
    "correct": "A"
  },
  {
    "id": 165,
    "text": "Se nel ciclo for viene omessa l'espressione di condizione:",
    "options": [
      "A. si genera un errore al linker",
      "B. si genera un errore di compilazione",
      "C. si genera un ciclo infinito",
      "D. il corpo del ciclo non viene eseguito"
    ],
    "correct": "C"
  },
  {
    "id": 166,
    "text": "L'istruzione for (c = 10; c > = 1; --c) è:",
    "options": [
      "A. corretta",
      "B. errata, serve 'c -=1' al posto di ' --c'",
      "C. errata, si puo' solo incrementare all'interno di un ciclo for",
      "D. errata, serve '< =' al posto di '> ='"
    ],
    "correct": "A"
  },
  {
    "id": 167,
    "text": "Se la condizione di continuazione del ciclo è inizialmente falsa:",
    "options": [
      "A. si genera un errore al linker",
      "B. si genera un errore di compilazione",
      "C. si genera un ciclo infinito",
      "D. il corpo del ciclo non viene eseguito"
    ],
    "correct": "D"
  },
  {
    "id": 168,
    "text": "In while( (ch = getchar()) != EOF )  viene eseguita prima:",
    "options": [
      "A. while",
      "B. ch = getchar()",
      "C. EOF",
      "D. !="
    ],
    "correct": "B"
  },
  {
    "id": 169,
    "text": "La funzione getchar() :",
    "options": [
      "A. legge un carattere dalla tastiera e lo memorizza in un buffer",
      "B. scrive un carattere a video e lo memorizza in un buffer",
      "C. legge un carattere dalla tastiera e lo ristampa a video",
      "D. scrive un carattere a video ma non  lo memorizza"
    ],
    "correct": "A"
  },
  {
    "id": 170,
    "text": "Quando viene chiamata getchar():",
    "options": [
      "A. Il programma termina con errore",
      "B. Il programma rimane in attesa",
      "C. Il programma termina con successo",
      "D. Il programma continua eseguendo la prima istruzione dopo l'istruzione getchar()"
    ],
    "correct": "B"
  },
  {
    "id": 171,
    "text": "L'istruzione printf(\"%c \\n\", 'a') stampa:",
    "options": [
      "A. 97a",
      "B. 97",
      "C. non stampa nulla",
      "D. a"
    ],
    "correct": "D"
  },
  {
    "id": 172,
    "text": "L'ASCII è:",
    "options": [
      "A. un codice per la codifica numerica di caratteri",
      "C. uno specificatore di conversione",
      "D. il metodo di memorizzazione per la funzione getchar"
    ],
    "correct": "A"
  },
  {
    "id": 173,
    "text": "EOF è:",
    "options": [
      "A. un carattere speciale che corrisponde a new line",
      "B. un carattere speciale che corrisponde a \\ t",
      "D. una variabile intera usata per terminare il programma"
    ],
    "correct": "C"
  },
  {
    "id": 174,
    "text": "Ctrl d (in linux) o Ctrl z (in Windows) sono interpretati come:",
    "options": [
      "A. errore",
      "B. EOF",
      "C. Invio",
      "D. getchar()"
    ],
    "correct": "B"
  },
  {
    "id": 175,
    "text": "I caratteri devono essere racchiusi entro virgolette singole per essere riconosciuti come:",
    "options": [
      "A. costanti di tipo carattere",
      "B. interi di tipo long int",
      "C. variabili di tipo carattere",
      "D. stringhe"
    ],
    "correct": "A"
  },
  {
    "id": 176,
    "text": "Per gli int l'int ervallo minimo va:",
    "options": [
      "A. da 0 a 65536",
      "B. da - infinito a +infinito",
      "C. da 0 a infinito",
      "D. da - 32767 a +32767"
    ],
    "correct": "D"
  },
  {
    "id": 177,
    "text": "Il tipo di dati char può essere utilizzato per:",
    "options": [
      "A. memorizzare stringhe di caratteri",
      "B. rappresentare inte ri nell'intervallo da - 32767 a +32767",
      "C. eseguire operazioni in virgola mobile",
      "D. rappresentare interi nell'intervallo da  - 127 a +127"
    ],
    "correct": "D"
  },
  {
    "id": 178,
    "text": "L'istruzione switch r ealizza una selezione:",
    "options": [
      "A. singola",
      "B. doppia",
      "C. mulitpla",
      "D. nulla"
    ],
    "correct": "C"
  },
  {
    "id": 179,
    "text": "L'istruzione switch include istruzioni per ciascuno dei:",
    "options": [
      "A. case",
      "B. default",
      "C. break",
      "D. if..else"
    ],
    "correct": "A"
  },
  {
    "id": 180,
    "text": "Nei case dell'istruzione switch si esegue il codice specificato dopo:",
    "options": [
      "A. :",
      "B. =",
      "C. :=",
      "D. {"
    ],
    "correct": "A"
  },
  {
    "id": 181,
    "text": "La parola chiave switch è seguita dal nome della variabile tra parentesi:",
    "options": [
      "A. quadrate",
      "B. tonde",
      "C. gr affe",
      "D. angolari"
    ],
    "correct": "B"
  },
  {
    "id": 182,
    "text": "Il break nell'istruzione switch:",
    "options": [
      "A. È sempre opzionale sia nei case che neil default",
      "B. È opzionale solo nel default",
      "C. È sempre necessario",
      "D. È opzionale solo nei case"
    ],
    "correct": "A"
  },
  {
    "id": 183,
    "text": "Il caso default si applica:",
    "options": [
      "A. Se non si verificano confronti positivi",
      "B. Se non si verificano confronti negativi",
      "D. mai"
    ],
    "correct": "A"
  },
  {
    "id": 184,
    "text": "Nei case del l'istruzione switch:",
    "options": [
      "A. puo' essere inclusa una sola azione",
      "B. devono essere incluse almeno due azioni",
      "C. non possono essere incluse azioni",
      "D. puo' essere inclusa una o piu' azioni"
    ],
    "correct": "D"
  },
  {
    "id": 185,
    "text": "Dimenticare un 'istruzione break quando è necessaria in un'istruzione switch è un errore:",
    "options": [
      "A. di compilazione",
      "B. di sintassi",
      "C. di esecuzione",
      "D. di linker"
    ],
    "correct": "B"
  },
  {
    "id": 186,
    "text": "La clausula di default:",
    "options": [
      "A. deve presentarsi per ultima d opo i case",
      "B. e' prassi posizionarla per ultima, dopo i case, ma non è un vincolo",
      "C. deve presentarsi per prima",
      "D. e' prassi posizionarla per prima, precedendo i case, ma non è un vincolo"
    ],
    "correct": "B"
  },
  {
    "id": 187,
    "text": "Ogni singolo case dell'istruzione switch può testare solamente un'espressione:",
    "options": [
      "A. variabile di tipo float",
      "B. costante di tipo carattere",
      "C. variabile di tipo carattere",
      "D. costante intera"
    ],
    "correct": "D"
  },
  {
    "id": 188,
    "text": "L'istruzione di iterazione do..while:",
    "options": [
      "A. non verifica l'esecuzione del corpo del ciclo",
      "B. verifica la condizione di continuazione del ciclo prima dell'esecuzione del corpo del ciclo",
      "C. verifica la condizione di continuazione del ciclo nel corpo del ciclo",
      "D. verifica la condizione di continuazione del ciclo dopo l'esecuzione del corpo del ciclo"
    ],
    "correct": "D"
  },
  {
    "id": 189,
    "text": "Nell'istruzione di iteraz ione do..while, la condizione di continuazione deve essere seguita da:",
    "options": [
      "A. :",
      "B. ;",
      "C. :=",
      "D. //"
    ],
    "correct": "B"
  },
  {
    "id": 190,
    "text": "Nell'istruzione di iterazione do..while, l'azione:",
    "options": [
      "A. viene eseguita almeno 1 volta",
      "B. viene eseguita almeno 2 volte",
      "C. viene eseguita almeno fino a EOF",
      "D. puo' non venire mai eseguita"
    ],
    "correct": "A"
  },
  {
    "id": 191,
    "text": "L'istruzione break si usa per:",
    "options": [
      "A. alterare il flusso di controllo",
      "B. terminare il programma",
      "C. mettere il programma in attesa",
      "D. eseguire un a chiamata esterna a funzione"
    ],
    "correct": "A"
  },
  {
    "id": 192,
    "text": "Dopo l'istruzione break in un ciclo for, l'esecuzione del programma:",
    "options": [
      "A. termina",
      "B. continua con con l'istruzione successiva al ciclo for",
      "C. continua con con l'istruzione successiva al  break",
      "D. continua con l'iterazione successiva"
    ],
    "correct": "B"
  },
  {
    "id": 193,
    "text": "Le istruzioni for (x = 1; x < = 4; ++x) { printf('%s', 'a'); break; printf('%s', 'a'); } stampano:",
    "options": [
      "A. a",
      "B. aa",
      "D. aaaa"
    ],
    "correct": "A"
  },
  {
    "id": 194,
    "text": "L'istruzione continue si usa per:",
    "options": [
      "A. alterare il flusso di controllo",
      "B. terminare il programma",
      "C. riprendere il programma che era stato posto in attesa",
      "D. eseguire una chiamata esterna a funzione"
    ],
    "correct": "A"
  },
  {
    "id": 195,
    "text": "Dopo l'istru zione continue in un ciclo for, l'esecuzione del programma:",
    "options": [
      "A. termina",
      "B. continua con con l'istruzione successiva al ciclo for",
      "C. continua con con l'istruzione successiva al continue",
      "D. continua con l'iterazione successiva"
    ],
    "correct": "D"
  },
  {
    "id": 196,
    "text": "Le istruzioni for (x = 1; x < = 4; ++x) { printf('%s', 'a'); continue; printf('%s', 'a');} stampano:",
    "options": [
      "A. a",
      "B. aa",
      "C. aaaaaaaa",
      "D. aaaa"
    ],
    "correct": "D"
  },
  {
    "id": 197,
    "text": "All'interno di una iterazione while, la sequenza di istruzioni break; continue; determina:",
    "options": [
      "A. che l'istruzione continue non sia mai eseguita",
      "B. chel'istruzione break non sia mai eseguita",
      "C. che entrambe le istruzioni break e continue siano eseguite",
      "D. che il loro effetto si annulli, proseguendo con l'istruzione succes siva"
    ],
    "correct": "A"
  },
  {
    "id": 198,
    "text": "Un operatore logico è:",
    "options": [
      "A. >",
      "B. ?",
      "C. =",
      "D. !"
    ],
    "correct": "D"
  },
  {
    "id": 199,
    "text": "L'istruzione if (x == 2 && y >= 120) è vera se:",
    "options": [
      "A. x è uguale a 2 e y uguale a 1000",
      "B. x è uguale a 1 e y uguale a 120",
      "C. x è uguale a 2 e y uguale a 102",
      "D. x è uguale a - 2 e y uguale a -3"
    ],
    "correct": "A"
  },
  {
    "id": 200,
    "text": "Se espressione1 vale 0 ed espressione2 vale 'nonzero', espressione1&&espressione2 vale:",
    "options": [
      "A. 0",
      "B. 1",
      "C. nonzero",
      "D. espressione1 * espressione2"
    ],
    "correct": "A"
  },
  {
    "id": 201,
    "text": "L'istruzione if (x == 2 || y>= 120) è falsa se:",
    "options": [
      "A. x è uguale a 2 e y uguale a 1000",
      "B. x è uguale a 1 e y uguale a 120",
      "C. x è uguale a 2 e y uguale a 102",
      "D. x è ug uale a - 2 e y uguale a -3"
    ],
    "correct": "D"
  },
  {
    "id": 202,
    "text": "Se espressione1 vale 0 ed espressione2 vale 'nonzero', espressione1||espressione2 vale:",
    "options": [
      "A. 0",
      "B. 1",
      "C. nonzero",
      "D. espressione1 * espressione2"
    ],
    "correct": "B"
  },
  {
    "id": 203,
    "text": "L'operatore ||:",
    "options": [
      "A. ha una precedenza più alta di &&",
      "B. ha una precedenza più bassa di &&",
      "D. non ha precedenze"
    ],
    "correct": "B"
  },
  {
    "id": 204,
    "text": "Gli operatori && e ||:",
    "options": [
      "A. || è associativo da destra a s inistra. && è associativo da sinistra a destra",
      "B. && è associativo da destra a sinistra. || è associativo da sinistra a destra",
      "C. sono entrambi associativi da sinistra a destra",
      "D. sono entrambi associativi da destra a sinistra"
    ],
    "correct": "C"
  },
  {
    "id": 205,
    "text": "L'istruzione if (x == 2 || y>= 120) viene eseguita piu' velocemente se:",
    "options": [
      "A. x=2",
      "B. y=120",
      "C. x=2 e y=120",
      "D. x=20 e y=12"
    ],
    "correct": "A"
  },
  {
    "id": 206,
    "text": "L'istruzione if(!(x >= 2)) :",
    "options": [
      "A. È vera se x=1",
      "B. È vera se x=2",
      "C. È vera se x=3",
      "D. non è scritta correttamente"
    ],
    "correct": "A"
  },
  {
    "id": 207,
    "text": "L'espressione !(condizione1 && condizione2) è equivalente a:",
    "options": [
      "A. (condizione1 && condizione2)",
      "B. (condizione1 || condizione2)",
      "C. !(condizione1 || condizione2)",
      "D. (!condizione1 || !condizione2)"
    ],
    "correct": "D"
  },
  {
    "id": 208,
    "text": "Il diagramma di flusso per istruzioni di sequenza è:",
    "options": [
      "A. una sequenza di cerchietti",
      "B. una sequenza di rettangoli",
      "C. una sequenza di rombi",
      "D. una sequenza di rettangoli arrotondati"
    ],
    "correct": "B"
  },
  {
    "id": 209,
    "text": "Il diagramma di flusso per istruzioni if è composto da:",
    "options": [
      "A. rombo e rettangolo",
      "B. rettangolo e rettangolo arrotondato",
      "C. rombo e due rettangoli",
      "D. sequenza di rombi e rettangoli"
    ],
    "correct": "A"
  },
  {
    "id": 210,
    "text": "Il diagramma di flusso per istruzioni if…else è composto da:",
    "options": [
      "A. rombo e rettangolo",
      "B. rettangolo e rettangolo arrotondato",
      "C. rombo e du e rettangoli",
      "D. sequenza di rombi e rettangoli"
    ],
    "correct": "C"
  },
  {
    "id": 211,
    "text": "Il diagramma di flusso per istruzioni switch è composto da:",
    "options": [
      "A. rombo e rettangolo",
      "B. rettangolo e rettangolo arrotondato",
      "C. rombo e due rettangoli",
      "D. sequenza di rombi e rettangoli"
    ],
    "correct": "D"
  },
  {
    "id": 212,
    "text": "Il diagramma di flusso per istruzioni do…while è composto da:",
    "options": [
      "A. rettangolo e rombo",
      "B. rettangolo e rettangolo arrotondato",
      "C. rombo e due rettangoli",
      "D. sequenza di rombi e rettangoli"
    ],
    "correct": "A"
  },
  {
    "id": 213,
    "text": "Il diagramma di flusso per istruzioni while è composto da:",
    "options": [
      "A. rettangolo e rombo",
      "B. rettangolo e rettangolo arrotondato",
      "D. sequenza di rombi e rettangoli"
    ],
    "correct": "A"
  },
  {
    "id": 214,
    "text": "Collegare istruzioni di controllo in sequenza per formare programmi strutturati è detto:",
    "options": [
      "A. annidamento",
      "B. accatastamento",
      "C. iterazione",
      "D. assemblaggio"
    ],
    "correct": "B"
  },
  {
    "id": 215,
    "text": "Le regole per costruire programmi strutturati indicano che qualsiasi rettangolo (azione) può essere sostituito con:",
    "options": [
      "A. due rettangoli con ricircolo",
      "B. due rombi con ricircolo",
      "C. due rettangoli in sequenza",
      "D. due rombi in sequenza"
    ],
    "correct": "C"
  },
  {
    "id": 216,
    "text": "La programmazione strutturata prevede l'uso solo di:",
    "options": [
      "A. accatastamento",
      "B. annidamento",
      "C. accatastamento, annidamento o sovrapposizione",
      "D. accatastamento o annidamento"
    ],
    "correct": "D"
  },
  {
    "id": 217,
    "text": "Qualsiasi forma di controllo in C può essere espressa in termini di solo:",
    "options": [
      "A. sequenza, for, switch",
      "B. sequenza, while, if",
      "C. sequenza, do…while, if…else",
      "D. sequenza"
    ],
    "correct": "B"
  },
  {
    "id": 218,
    "text": "La libreria standard del C fornisce funzioni per eseguire:",
    "options": [
      "A. grafica avanzata",
      "B. comuni calcoli matematici, manipolazioni di stringhe, input/output, giochi tradizionali",
      "C. calcoli matematici di ogni tipo",
      "D. com uni calcoli matematici, manipolazioni di stringhe, input/output"
    ],
    "correct": "D"
  },
  {
    "id": 219,
    "text": "Le funzioni definite dal programmatore:",
    "options": [
      "A. sono scritte una sola volta e sono nascoste alle altre funzioni",
      "B. sono scritte una sola volta e sono visibili alle altre funzioni",
      "C. sono scritte piu' di una volta e sono nascoste alle altre funzioni",
      "D. sono scritte piu' di una volta e sono visibili alle altre funzioni"
    ],
    "correct": "A"
  },
  {
    "id": 220,
    "text": "La chiamata di  funzione:",
    "options": [
      "A. specifica solo il nome della funzione",
      "B. fornisce solo gli argomenti",
      "C. specifica il nome della funzione e fornisce gli argomenti",
      "D. specifica l'invocazione gerarchica annidata dei parametri di funzione"
    ],
    "correct": "C"
  },
  {
    "id": 221,
    "text": "Le variabili definite nelle definizioni di funzione:",
    "options": [
      "A. sono tutte locali",
      "B. possono essere sia locali che non locali",
      "C. sono modulari",
      "D. sono tutte non locali"
    ],
    "correct": "A"
  },
  {
    "id": 222,
    "text": "Far svolgere a ciascuna funzione un compito specifico si dice:",
    "options": [
      "A. modularizzazione",
      "B. astrazione",
      "C. scomposizione",
      "D. funzionalizzazione"
    ],
    "correct": "B"
  },
  {
    "id": 223,
    "text": "Spezzare una funzione in varie funzioni più piccole si dice:",
    "options": [
      "A. modularizzazione",
      "B. astrazione",
      "D. funzionalizzazione"
    ],
    "correct": "C"
  },
  {
    "id": 224,
    "text": "Gli argomenti delle funzioni sono racchiusi tra parentesi:",
    "options": [
      "A. quadrate",
      "B. tonde",
      "C. graffe",
      "D. angolari"
    ],
    "correct": "B"
  },
  {
    "id": 225,
    "text": "Le funzioni nella libreria math che restituiscono valori in virgola mobile restituiscono il tipo di dati:",
    "options": [
      "A. float",
      "B. double",
      "C. int",
      "D. double o float"
    ],
    "correct": "B"
  },
  {
    "id": 226,
    "text": "Per usare le funzioni della libreria math, è necessario incl udere:",
    "options": [
      "A. #include < math.h >",
      "B. include < math.h >",
      "C. #include < math >",
      "D. include math.h"
    ],
    "correct": "A"
  },
  {
    "id": 227,
    "text": "Il valore assoluto di (y*y*y -3) si scrive:",
    "options": [
      "A. pow( fabs( y, -3 ) 3 )",
      "B. pow( fabs( y,3 ) - 3 )",
      "C. fabs( pow( y,3 ) - 3 )",
      "D. fabs(  pow( y, -3 ) 3 )"
    ],
    "correct": "C"
  },
  {
    "id": 228,
    "text": "Il prototipo di una funzione va inserito:",
    "options": [
      "A. nel main o in altra funzione",
      "B. dopo la chiamata a funzione",
      "C. in qualunque punto del programma",
      "D. prima di usare la funzione"
    ],
    "correct": "D"
  },
  {
    "id": 229,
    "text": "L'istruzione int funz(double y); indica che:",
    "options": [
      "A. funz si aspetta di ricevere un valore double",
      "B. funz restituisce un valore double",
      "C. funz si aspetta di ricevere un valore int",
      "D. funz restituisce un valore int"
    ],
    "correct": "A"
  },
  {
    "id": 230,
    "text": "L'int alla sinistra del nome della funzione informa il compilatore che:",
    "options": [
      "A. la funzione restituisce un intero",
      "B. la funzione richiede un input intero",
      "C. la funzione op era esclusivamente con variabili intere",
      "D. la funzione non richiede un intero"
    ],
    "correct": "A"
  },
  {
    "id": 231,
    "text": "Il compilatore utilizza il prototipo della funzione per accertarsi che:",
    "options": [
      "A. il tipo di ritorno sia coerente con il contes to nel quale è chiamata la funzione",
      "B. i tipi degli argomenti non siano inclusi",
      "C. i tipi degli argomenti non siano ordinati",
      "D. il numero di argomenti sia maggiore o uguale a quello della definizione"
    ],
    "correct": "A"
  },
  {
    "id": 232,
    "text": "La chiamata di una funzione è invocata:",
    "options": [
      "A. in qualunque punto del programma",
      "B. prima del prototipo",
      "C. nel main o in altra funzione",
      "D. nella sua definizione"
    ],
    "correct": "C"
  },
  {
    "id": 233,
    "text": "La definizione di una funzione è inserit a:",
    "options": [
      "A. prima il prototipo",
      "B. dopo il prototipo",
      "D. all'interno della sua dichiarazione"
    ],
    "correct": "B"
  },
  {
    "id": 234,
    "text": "Il tipo di valore di ritorno void indica che una funzione:",
    "options": [
      "A. restituisce la stringa void",
      "B. non richiede alcuna variabile di input",
      "C. non restituisce alcun valore",
      "D. restituisce 0 se corretta, non zero se errata"
    ],
    "correct": "C"
  },
  {
    "id": 235,
    "text": "La lista di parametri da passare a una funzione è un elenco separato da:",
    "options": [
      "A. punto (  . )",
      "B. trattino ( -  )",
      "C. punto e virgola ( ; )",
      "D. virgola ( , )"
    ],
    "correct": "D"
  },
  {
    "id": 236,
    "text": "L'istruzione int funz(int x, y, double z); è:",
    "options": [
      "A. errata perché non si possono dichiarare int e double nella stessa lista argomenti",
      "B. corretta",
      "C. errata perché  non si può omettere int per la variabile y",
      "D. errata perché non si possono indicare più di due argomenti"
    ],
    "correct": "C"
  },
  {
    "id": 237,
    "text": "Il main restituisce:",
    "options": [
      "A. 0 se return è omessa",
      "B. errore se return è omessa",
      "C. 1 se return è omessa",
      "D. non zero  se return e' incluso"
    ],
    "correct": "A"
  },
  {
    "id": 238,
    "text": "Il compilatore usa i prototipi di funzione per:",
    "options": [
      "A. definire le funzioni",
      "B. correggere errori di programmazione",
      "C. convalidare le chiamate delle funz ioni",
      "D. chiamare le funzioni nel main"
    ],
    "correct": "C"
  },
  {
    "id": 239,
    "text": "La riga del prototipo di funzione si conclude con:",
    "options": [
      "A. {",
      "B. ;",
      "C. }",
      "D. )"
    ],
    "correct": "B"
  },
  {
    "id": 240,
    "text": "La riga della definizione di funzione si conclude con:",
    "options": [
      "A. {",
      "B. ;",
      "C. }",
      "D. )"
    ],
    "correct": "A"
  },
  {
    "id": 241,
    "text": "Includere i nomi dei parametri nei prototipi:",
    "options": [
      "A. È necessario (se non presenti si generano errori di compilazione)",
      "B. È facoltativo ma consigliabile",
      "C. È facoltativo ma sconsigliabile",
      "D. È da evitare (se presenti si generano errori di compilazionee)"
    ],
    "correct": "B"
  },
  {
    "id": 242,
    "text": "Il tipo void nel prototipo di funzione richiede:",
    "options": [
      "A. il tipo int nella corrispondente definizione di funzione",
      "B. nessun tipo specificato nella corrispondente definizione di funzione",
      "C. un tipo qualsiasi nella corrispondente definizione di funzione",
      "D. il tipo v oid nella corrispondente definizione di funzione"
    ],
    "correct": "D"
  },
  {
    "id": 243,
    "text": "Per \"coercizione degli argomenti\" si intende:",
    "options": [
      "A. l'impossibilità di modificare il valore degli argomenti",
      "B. l'impossibilità di modificare il t ipo degli argomenti",
      "D. la forzatura del tipo degli argomenti"
    ],
    "correct": "D"
  },
  {
    "id": 244,
    "text": "La conversione di un double in un int:",
    "options": [
      "A. avviene per troncamento",
      "B. avviene per appro ssimazione all'intero superiore",
      "C. avviene senza perdita di accuratezza",
      "D. non è gestibile dal compilatore (restiuisce errore)"
    ],
    "correct": "A"
  },
  {
    "id": 245,
    "text": "In un'espressione con tipi misti, il compilatore:",
    "options": [
      "A. converte t utti i tipi presenti in int",
      "B. converte tutti i tipi presenti in double",
      "C. converte tutti i tipi presenti in long double",
      "D. esegue una copia temporanea dei valori da convertire"
    ],
    "correct": "D"
  },
  {
    "id": 246,
    "text": "Un valore si può convertire in un tipo più basso usando:",
    "options": [
      "A. cast",
      "B. void",
      "C. return",
      "D. double"
    ],
    "correct": "A"
  },
  {
    "id": 247,
    "text": "Se uno dei valori è long double, l'altro si converte in:",
    "options": [
      "A. long double",
      "B. double",
      "C. long int",
      "D. int"
    ],
    "correct": "A"
  },
  {
    "id": 248,
    "text": "Nel C la struttura dati è nota come:",
    "options": [
      "A. record di attivazione",
      "B. stack",
      "C. funzione",
      "D. automatica"
    ],
    "correct": "B"
  },
  {
    "id": 249,
    "text": "Nel C la struttura dati è di tipo LIFO:",
    "options": [
      "A. l'ultimo elemento inserito è l'ulitmo a essere rimosso",
      "B. l'ultimo elemento inserito è il primo a essere rimosso",
      "C. gli elementi inseriti sono rimossi in ordine random",
      "D. il primo elemento inserito è il primo a essere rimosso"
    ],
    "correct": "B"
  },
  {
    "id": 250,
    "text": "Le variabili automatiche sono:",
    "options": [
      "A. variabili locali delle funzioni",
      "B. variabili il cui tipo è convertito automaticamente",
      "C. variabili locali della sola funzione main",
      "D. variabili il cui valore è convertito automaticamente"
    ],
    "correct": "A"
  },
  {
    "id": 251,
    "text": "Ogni funzione alla fine deve restituire il controllo:",
    "options": [
      "A. al main",
      "B. alla funzione chiamata",
      "C. al sistema operativo",
      "D. alla funzione chiamante"
    ],
    "correct": "D"
  },
  {
    "id": 252,
    "text": "Il record di attivazione contiene:",
    "options": [
      "A. l'indirizzo di ritorno alla funzio ne chiamata",
      "B. l'indirizzo di ritorno alla funzione chiamante",
      "C. l'indirizzo di ritorno alla funzione chiamata e le variabili locali",
      "D. l'indirizzo di ritorno alla funzione chiamante e le variabili locali"
    ],
    "correct": "D"
  },
  {
    "id": 253,
    "text": "Se la  funzione chiamata torna alla funzione chiamante:",
    "options": [
      "A. si esegue il push del record di attivazione della funzione chiamata",
      "B. si esegue il pop del record di attivazione della funzione chiamata",
      "D. si esegue il pop del record di attivazione della funzione chiamante"
    ],
    "correct": "B"
  },
  {
    "id": 254,
    "text": "Quando una funzione chiamata torna alla sua funzione chiamante:",
    "options": [
      "A. le variabili automatiche della funzione chiamata vengono rimosse",
      "B. le variabili automatiche della funzione chiamante vengono rimosse",
      "C. le variabili globali della funzione chiamata vengono rimosse",
      "D. le variabili globali della funzione chiamata vengono rimosse"
    ],
    "correct": "A"
  },
  {
    "id": 255,
    "text": "Si verifica u no stack overflow quando:",
    "options": [
      "A. sono stati rimossi tutti record di attivazione",
      "B. si verifica un errore irreverisbile di compilazione",
      "C. si esaurisce la memoria per i record di attivazione",
      "D. si utilizzano più record di attivazione di quante funzioni sono sta te create"
    ],
    "correct": "C"
  },
  {
    "id": 256,
    "text": "Quando si raggiunge la parentesi graffa destra di chiusura di main avviene:",
    "options": [
      "A. la sola rimozione del record dallo stack ma non si realizza il ritorno al sistema operativo",
      "B. il ritorno al sistema  operativo ma il record dallo stack viene mantenuto",
      "C. prima la rimozione del record dallo stack e quindi il ritorno al sistema operativo",
      "D. la rimozione del sistema operativo"
    ],
    "correct": "C"
  },
  {
    "id": 257,
    "text": "A fine esecuzione, la memori a per le variabili automatiche di main:",
    "options": [
      "A. non è più accessibile",
      "B. rimane accessibile in sola lettura",
      "C. rimane accessibile in sola scrittura",
      "D. rimane accessibile in lettura e scrittura"
    ],
    "correct": "A"
  },
  {
    "id": 258,
    "text": "Ogni file di intestazione della libreria standard include:",
    "options": [
      "A. prototipi, definizioni dei tipi di dati e delle costanti",
      "B. solo i prototipi",
      "C. solo le definizioni dei tipi di dati"
    ],
    "correct": ""
  },
  {
    "id": 259,
    "text": "Il file di intestazione limits.h contiene:",
    "options": [
      "A. i limiti per i valori interi del sistema",
      "B. i prototipi di funzioni per i calcoli matematici con i limiti",
      "C. i limiti di lunghezza delle stringhe nelle funzioni di input/ output",
      "D. i limiti per le lunghezze delle funzioni e dei file"
    ],
    "correct": "A"
  },
  {
    "id": 260,
    "text": "Il file di intestazione time.h contiene:",
    "options": [
      "B. contiene i prototipi di funzione per velocizzare la compilazione",
      "C. con tiene le definizioni di funzioni da eseguire in tempi definiti"
    ],
    "correct": "D"
  },
  {
    "id": 261,
    "text": "I file di intestazione definiti dal programmatore devono avere estensione:",
    "options": [
      "A. .prog",
      "B. .gcc",
      "C. .h",
      "D. .c"
    ],
    "correct": "C"
  },
  {
    "id": 262,
    "text": "I file di intestazione definiti dal programmatore devono essere inclusi fra:",
    "options": [
      "A. < >",
      "B. ' '",
      "C. ( )",
      "D. [ ]"
    ],
    "correct": "B"
  },
  {
    "id": 263,
    "text": "Quando la copia del valore viene  passata alla funzione chiamata, si dice che gli argomenti sono passati per:",
    "options": [
      "A. valore",
      "B. riferimento",
      "D. intestazione"
    ],
    "correct": "A"
  },
  {
    "id": 264,
    "text": "Quando gli argomenti sono passati per riferimento, la funzione chiamante:",
    "options": [
      "A. non permette alla funzione chiamata di modificare il valore della variabile originaria",
      "B. permette alla funzione chiamata di modificare il vaolre della variabile originaria",
      "C. si ottiene un errore di sintassi",
      "D. si ottiene un errore di compilazion e"
    ],
    "correct": "B"
  },
  {
    "id": 265,
    "text": "Per utilizzare la funzione rand() è necessario inserire:",
    "options": [
      "A. #include < rand.h >",
      "B. #include < stdlib.h >",
      "C. #include < rand >",
      "D. #include < stdlib >"
    ],
    "correct": "B"
  },
  {
    "id": 266,
    "text": "La funzione rand() restituisce un numero casuale compreso fra:",
    "options": [
      "A. 1 e 6",
      "B. 0 e almeno 2147483647",
      "C. 1 e almeno 2147483647",
      "D. 0 e 6"
    ],
    "correct": "B"
  },
  {
    "id": 267,
    "text": "L'istruzione printf('%u', rand() % 2); resti tuisce:",
    "options": [
      "A. la stampa di 0 o 1",
      "B. la stampa di 1 o 2",
      "C. la stampa di 2",
      "D. la stampa del valore massimo per rand() diviso 2"
    ],
    "correct": "A"
  },
  {
    "id": 268,
    "text": "Le costanti nelle enumerazioni è buona norma indic arle:",
    "options": [
      "A. con almeno due cifre all'inizio del nome",
      "B. con lettere tutte minuscole",
      "C. con prima lettera maiuscola e successive minuscole",
      "D. con lettere tutte maiuscole"
    ],
    "correct": "D"
  },
  {
    "id": 269,
    "text": "I valori in un enum iniziano con:",
    "options": [
      "A. -1",
      "B. 0",
      "C. 1",
      "D. EOF"
    ],
    "correct": "B"
  },
  {
    "id": 270,
    "text": "I valori in un enum:",
    "options": [
      "A. vengono incrementati di 1",
      "B. vengono decrementati di 1",
      "C. hanno tutti lo stesso valore (quello iniziale)",
      "D. hanno tutti lo stesso valore, pari a zero"
    ],
    "correct": "A"
  },
  {
    "id": 271,
    "text": "Le c ostanti nelle enumerazioni sono comprese fra parentesi:",
    "options": [
      "A. graffe",
      "B. tonde",
      "C. quadre",
      "D. angolari"
    ],
    "correct": "A"
  },
  {
    "id": 272,
    "text": "Le costanti nelle enumerazioni sono separate da:",
    "options": [
      "A. virgola ( , )",
      "B. punto e virgola ( ; )",
      "C. linea ( -  )",
      "D. and commercia le ( & )"
    ],
    "correct": "A"
  },
  {
    "id": 273,
    "text": "I valori in un enum possono essere forzati a valori specifici usando:",
    "options": [
      "A. uguale seguito da due punti ( =: )",
      "B. due punti seguito da uguale ( := )",
      "D. uguale ( = )"
    ],
    "correct": "D"
  },
  {
    "id": 274,
    "text": "Gli identificatori in un'enumerazione :",
    "options": [
      "A. devono essere unici, e i valori non possono essere duplicati",
      "B. devono essere unici, e i valori possono essere duplicati",
      "C. possono essere duplicati, e i valori devono essere unici",
      "D. possono essere duplic ati, e anche i valori possono essere duplicati"
    ],
    "correct": "B"
  },
  {
    "id": 275,
    "text": "L'istruzione printf( \"%d\", var); con var di tipo enum, stampa:",
    "options": [
      "A. un intero",
      "B. una stringa di testo",
      "C. nulla, genera un errore di compilazione",
      "D. nulla, ma non genera errori di compilazione"
    ],
    "correct": "A"
  },
  {
    "id": 276,
    "text": "L'istruzione if( MON == var) con var di tipo enum:",
    "options": [
      "A. È errata, non si può confrontare un enum con la costante MON",
      "B. È errata, i l confronto nell'if si realizza utilizzando un solo uguale",
      "C. È corretta se MON è un identificatore dell'enum",
      "D. È errata, va invertito l'ordine fra MON e var"
    ],
    "correct": "C"
  },
  {
    "id": 277,
    "text": "L'istruzione enum Week day;  nel main:",
    "options": [
      "A. È errata, va ripo rtato Week day enum;",
      "B. È errata, va posta al di fuori del main",
      "C. È errata, va riportato enum Week = enum day;",
      "D. È corretta, dichiara la variabile day di tipo enum Week"
    ],
    "correct": "D"
  },
  {
    "id": 278,
    "text": "Il periodo dura nte il quale l'identificatore esiste nella memoria si dice:",
    "options": [
      "A. campo di azione",
      "B. permanenza",
      "C. collegamento",
      "D. regola di azione"
    ],
    "correct": "B"
  },
  {
    "id": 279,
    "text": "La posizione in cui l'identificatore può essere menzionato in un programma si dice:",
    "options": [
      "A. campo di azione",
      "B. permanenza",
      "C. collegamento",
      "D. regola di azione"
    ],
    "correct": "A"
  },
  {
    "id": 280,
    "text": "L'informazione se l'identificatore è conosciuto soltanto nel file sorgente corrente o in qualunque file sorgente è  detta:",
    "options": [
      "A. campo di azione",
      "B. permanenza",
      "C. collegamento",
      "D. regola di azione"
    ],
    "correct": "C"
  },
  {
    "id": 281,
    "text": "Quale dei seguenti NON è uno specificatore di classe di memoria:",
    "options": [
      "A. extern",
      "B. static",
      "C. intern",
      "D. auto"
    ],
    "correct": "C"
  },
  {
    "id": 282,
    "text": "Le variabili con permanenza in memoria automatica sono create:",
    "options": [
      "A. all'inizio dell'esecuzione del programma",
      "B. quando il controllo del programma esce dal blocco nel quale sono definite",
      "C. quando il controllo del programma le utilizza la prima volta",
      "D. quando il controllo del programma entra nel blocco nel quale sono definite"
    ],
    "correct": "D"
  },
  {
    "id": 283,
    "text": "Le variabili locali, per impostazione predefinita:",
    "options": [
      "A. hanno permanenza in memoria permamente e l'impiego della parola chiave auto è quindi opzionale",
      "C. hanno permanenza in memoria permamente solo se è utilizzata la parola chiave auto",
      "D. hanno permanenza in memoria automatica solo se è utilizzata la parola chiave auto"
    ],
    "correct": "B"
  },
  {
    "id": 284,
    "text": "Per le variabili static la memoria è allocata e inizializzata:",
    "options": [
      "A. soltanto una volta, prima che il programma inizi l'esecuzione",
      "B. ogni volta che il programma le utilizza",
      "C. soltanto una volta, quando il controllo del programma entra nel blocco che le utilizza",
      "D. tante volte quante il loro valore viene modificato, prima che il programma inizi l'esecuzione"
    ],
    "correct": "A"
  },
  {
    "id": 285,
    "text": "La classe di memoria extern, per impostazione predefinita,si utilizza per:",
    "options": [
      "A. variabili automatiche",
      "B. variabili globali",
      "C. costanti",
      "D. operandi"
    ],
    "correct": "B"
  },
  {
    "id": 286,
    "text": "Le variabili globali hanno il campo d'az ione esteso:",
    "options": [
      "A. alla funzione",
      "B. al file",
      "C. al blocco",
      "D. al sistema operativo"
    ],
    "correct": "B"
  },
  {
    "id": 287,
    "text": "Le etichette sono identificatori con il campo d'azione esteso:",
    "options": [
      "A. alla funzione",
      "B. al file",
      "C. al blocco",
      "D. al sistema operat ivo"
    ],
    "correct": "A"
  },
  {
    "id": 288,
    "text": "Nel calcolo con ricorsione, il caso di base determina:",
    "options": [
      "A. un errore",
      "B. la chiamata all'ultima funzione ricorsiva",
      "C. la restituzione di un numero",
      "D. la chiamata alla prima fu nzione ricorsiva"
    ],
    "correct": "C"
  },
  {
    "id": 289,
    "text": "Nel calcolo con ricorsione, per restituire un valore, il passo di ricorsione include un'istruzione:",
    "options": [
      "A. return",
      "B. for",
      "C. printf",
      "D. if (o if..else)"
    ],
    "correct": "A"
  },
  {
    "id": 290,
    "text": "Nel calco lo con ricorsione, il passo di ricorsione viene eseguito mentre:",
    "options": [
      "A. la chiamata originaria alla funzione fallisce",
      "B. la chiamata originaria alla funzione si arresta definitivamente",
      "C. la chiamata originaria alla funzione si arresta, in attesa del risultato dal passo di ricorsione",
      "D. la chiamata originaria prosegue, simultaneamente ai passi di ricorsione"
    ],
    "correct": "C"
  },
  {
    "id": 291,
    "text": "La ricorsione termina quando la chiamata originaria della funzione:",
    "options": [
      "A. restituisce il risultato finale alla sua fu nzione chiamante",
      "B. restituisce zero",
      "C. restituisce il risultato finale alla sua funzione chiamata",
      "D. restituisce il valore 1 alla sua funzione chiamante"
    ],
    "correct": "A"
  },
  {
    "id": 292,
    "text": "Per ottenere interi grandi dalla funzione fattoriale, è oppo rtuno utilizzare il tipo:",
    "options": [
      "A. long int",
      "B. unsigned long long int",
      "C. unsigned super int",
      "D. long long long"
    ],
    "correct": "B"
  },
  {
    "id": 293,
    "text": "La ricosione infinta determina:",
    "options": [
      "A. l'accelerazione delle prestazioni nell'esecuzione delle funzioni ricorsive",
      "B. la restituizione del caso base",
      "D. l'esaurimento della memoria"
    ],
    "correct": "D"
  },
  {
    "id": 294,
    "text": "Sia l'iterazione che la ricorsione si basano su :",
    "options": [
      "A. una struttura di controllo",
      "B. una struttura di selezione di tipo switch",
      "C. una struttura di iterazione con variabile sentinella",
      "D. una struttura di selezione e una di iterazione con variabile sentinella"
    ],
    "correct": "A"
  },
  {
    "id": 295,
    "text": "Sia l'iterazione che la ricorsione richiedono ciascuna un test nel programma di:",
    "options": [
      "B. disponibilità di risorse di memoria",
      "C. selezione",
      "D. terminazio ne"
    ],
    "correct": "D"
  },
  {
    "id": 296,
    "text": "Il motivo principale per cui si preferisce la ricorsione all'iterazione è:",
    "options": [
      "A. la realizzazione di un programma più moderno",
      "B. la realizzazione di un programma più intuitivo",
      "C. la realizzazi one di un programma dall'esecuzione più lenta",
      "D. nessun motivo"
    ],
    "correct": "B"
  },
  {
    "id": 297,
    "text": "La ricorsione spesso richiede più memoria dell'iterazione per:",
    "options": [
      "A. la facilità con cui si ricade in ricorsioni infinite",
      "B. l'uso piu' frequente di chiamate a funzione",
      "C. l'impiego di variabili di tipo piu' ampio",
      "D. il tipo di memoria impiegata"
    ],
    "correct": "B"
  },
  {
    "id": 298,
    "text": "Gli array sono:",
    "options": [
      "A. strutture di funzioni costituite da f unzioni non correlate e di ogni tipo",
      "B. strutture di dati costituite da dati non correlati e di ogni tipo",
      "C. strutture di funzioni costituite da funzioni dello stesso tipo",
      "D. strutture di dati costituite da dati correlati e dello stesso tipo"
    ],
    "correct": "D"
  },
  {
    "id": 299,
    "text": "Nel programma C, per fare riferimento a un particolare elemento dell'array, specifichiamo:",
    "options": [
      "A. il nome, il valore esadecimale della locazione di memoria, e il numero di posizione dell'elemento nell'array",
      "B. solo il numero di pos izione dell'elemento nell'array",
      "C. solo il nome dell'array",
      "D. il nome dell'array e il numero di posizione dell'elemento nell'array"
    ],
    "correct": "D"
  },
  {
    "id": 300,
    "text": "Il primo elemento in ogni array è l'elemento di posizione:",
    "options": [
      "A. 0",
      "B. 1",
      "C. -1",
      "D. 100"
    ],
    "correct": "A"
  },
  {
    "id": 301,
    "text": "Il nome di un array NON può iniziare con:",
    "options": [
      "A. lettera minuscola",
      "B. cifra",
      "C. sottilineatura (underscore)",
      "D. le lettere 'arr'"
    ],
    "correct": "B"
  },
  {
    "id": 302,
    "text": "In un array, il numero di posizione tra le pare ntesi quadre è chiamato:",
    "options": [
      "A. indice",
      "B. sommario",
      "C. codice",
      "D. argomento"
    ],
    "correct": "A"
  },
  {
    "id": 303,
    "text": "L'istruzione c[a + b] += 4; con a=1 e b=2 interi:",
    "options": [
      "A. addiziona 2 all'elemento 12 dell'array c",
      "B. addiziona 4 all'elemento 12 dell'array c",
      "D. addiziona 4 all'elemento 3 dell'array c"
    ],
    "correct": "D"
  },
  {
    "id": 304,
    "text": "Printf('%d', s[1] + s[2]); restituisce:",
    "options": [
      "A. errore, servono due specificatori di conversione %d",
      "B. errore, non si può effettuare la so mma s[1] + s[2]",
      "C. la stampa della somma degli elementi 1 e 2 dell'array s",
      "D. errore, andava indicato 1[s] + 2[s]"
    ],
    "correct": "C"
  },
  {
    "id": 305,
    "text": "Size_t rappresenta:",
    "options": [
      "A. un tipo intero senza segno raccomandato per gli indici di un array",
      "B. un tipo intero senza segno da evitare per gli indici di un array",
      "C. un tipo float raccomandato per gli indici di un array",
      "D. un tipo float da evitare per gli indici di un array"
    ],
    "correct": "A"
  },
  {
    "id": 306,
    "text": "Int c[100] = {0}; determina:",
    "options": [
      "A. l'ini zializzazione a 0 del valore alla posizione 100",
      "B. l'inizializzazione a 100 del valore alla posizione 0",
      "C. l'inizializzazione a 0 di tutti i valori dell'array c",
      "D. errore, per inizializzare serve il valore di ogni elemento dell'array"
    ],
    "correct": "C"
  },
  {
    "id": 307,
    "text": "Per definire la costante simbolica per la dimensione degli array si utlizza:",
    "options": [
      "A. #define",
      "B. #include",
      "C. ",
      "D. "
    ],
    "correct": "A"
  },
  {
    "id": 308,
    "text": "Se si applica lo specificatore static alla definizione di un array locale:",
    "options": [
      "A. non si possono modificare gli elementi dell'array ogni volta che la funzione è chiamata",
      "B. non si possono porre a zero i valori dell'array quando la funzione è chiamata",
      "C. non si deve creare e inizializzare l'array ogni volta che la funzione è chiamata",
      "D. si deve creare e inizializzare l'array ogni volta che la funzione è chiamata"
    ],
    "correct": "C"
  },
  {
    "id": 309,
    "text": "Se si applica lo specificatore static alla definizione di un array locale, l'array:",
    "options": [
      "A. non verrà distrutto ogni volta che si esce dalla funzione nel programma",
      "B. verrà distrutto ogni volta che si esce dalla funzione nel programma",
      "C. non potrà essere usato nel main",
      "D. non potrà usare la costante simbolica per definire la sua dimensione"
    ],
    "correct": "A"
  },
  {
    "id": 310,
    "text": "Per i programmi con funzioni chiamate frequentemente e che contengono array grandi, se si applica lo  specificatore static alla definizione di un array locale:",
    "options": [
      "A. si aumenta il tempo di esecuzione del programma",
      "B. si riduce il tempo di esecuzione del programma",
      "C. il tempo di esecuzione del programma rimane invariato",
      "D. il tempo di esecuzione del programma aumenta solo se l'array è di interi"
    ],
    "correct": "B"
  },
  {
    "id": 311,
    "text": "Se non inizializzate esplicitamente un a rray static, gli elementi di quell'array vengono automaticamente  inizializzati a:",
    "options": [
      "A. EOF",
      "B. 0",
      "C. valore spazzatura",
      "D. '\\0'"
    ],
    "correct": "B"
  },
  {
    "id": 312,
    "text": "Se non inizializzate esplicitamente un array automatico, gli elementi di qu ell'array vengono automaticamente  inizializzati a:",
    "options": [
      "A. EOF",
      "B. 1",
      "C. valore spazzatura",
      "D. '\\0'"
    ],
    "correct": "C"
  },
  {
    "id": 313,
    "text": "Per passare come argomento un array a una funzione dovete specificare:   DO NOT PAY FOR THIS DOCUMENT - FREE DOCUMENT - NO DOCSITY - NON PAGARE PER QUESTO DOCUMENTO   DO NOT PAY FOR THIS DOCUMENT - FREE DOCUMENT - NO DOCSITY - NON PAGARE PER QUESTO DOCUMENTO",
    "options": [
      "A. il nome dell'array senza alcuna parentesi",
      "B. il nome dell'array con parentesi graffe",
      "C. il nome dell'array con parentesi tonde",
      "D. il nome dell'array con parentesi angolari"
    ],
    "correct": "A"
  },
  {
    "id": 314,
    "text": "Il nome dell'array ha come valore:",
    "options": [
      "A. l'indirizzo dell'ultim o elemento dell'array",
      "B. la dimensione dell'array",
      "C. l'indirizzo del primo elemento dell'array",
      "D. 0031F930"
    ],
    "correct": "C"
  },
  {
    "id": 315,
    "text": "&array è equivalente a:",
    "options": [
      "A. array[1]",
      "B. array(1)",
      "C. array(0)",
      "D. array[0]"
    ],
    "correct": "D"
  },
  {
    "id": 316,
    "text": "Per stampare indirizzi con printf si usa lo specificatore di conversione:",
    "options": [
      "A. %p",
      "B. %i",
      "C. %a",
      "D. %z"
    ],
    "correct": "A"
  },
  {
    "id": 317,
    "text": "La tecnica bubble sort per ordinare l'array:",
    "options": [
      "A. non è iterativa, c onfronta e ordina tutti gli elementi simulatenamente",
      "B. È iterativa, confronta e ordina gli elementi a coppie",
      "C. non è iterativa e si avvale di una variabile ausiliaria",
      "D. È ricorsiva, confronta e ordina tutti gli elementi simulatenamente"
    ],
    "correct": "B"
  },
  {
    "id": 318,
    "text": "I puntatori sono:",
    "options": [
      "A. variabili i cui valori sono interi",
      "B. strutture di dati costituite da dati correlati e dello stesso tipo",
      "C. funzioni costituite con variabili dello stesso tipo",
      "D. variabili i cui valori sono indirizzi di memoria"
    ],
    "correct": "D"
  },
  {
    "id": 319,
    "text": "Far riferimento a un valore per mezzo di un puntatore si dice:",
    "options": [
      "A. indirezione",
      "B. imposizione",
      "C. ingiunzione",
      "D. polarizzazione"
    ],
    "correct": "A"
  },
  {
    "id": 320,
    "text": "La definizione del puntatore xPtr a intero si realizza con:",
    "options": [
      "A. int &xPtr;",
      "B. int *xPtr;",
      "C. int xPtr;",
      "D. punt xPtr;"
    ],
    "correct": "B"
  },
  {
    "id": 321,
    "text": "La definizione dei puntatori xPtr e yPtr si può scrivere:",
    "options": [
      "A. int * xPtr, yPtr;",
      "B. int *xPtr, *yPtr;",
      "C. punt xPtr, yPtr;",
      "D. int & xPtr, yPtr;"
    ],
    "correct": "B"
  },
  {
    "id": 322,
    "text": "Un puntatore NON può essere inizializzato a:",
    "options": [
      "A. NULL",
      "B. 0",
      "C. 1",
      "D. indirizzo"
    ],
    "correct": "C"
  },
  {
    "id": 323,
    "text": "L'istruzione yPtr = &y; è:",
    "options": [
      "A. errata, serve operatore freccia ( -->) al posto di uguale (=)",
      "B. corretta, assegna la variabile puntatore yPtr all'indirizzo della variabile y",
      "D. corr etta, assegna l'indirizzo della variabile y alla variabile puntatore yPtr"
    ],
    "correct": "D"
  },
  {
    "id": 324,
    "text": "L'operatore unario * di indirezione applicato a un puntatore restituisce:",
    "options": [
      "A. il valore contenuto nella locazione di memoria puntata",
      "B. l'indirizzo della locazione di memoria puntata",
      "C. la moltiplicazione del valore contenuto nella locazione di memoria p untata",
      "D. la moltiplicazione dell'indirizzo della locazione di memoria puntata"
    ],
    "correct": "A"
  },
  {
    "id": 325,
    "text": "Dato int x=1 e int *xPtr = &x, l'istruzione   printf(\"%p\", &x); stampa:",
    "options": [
      "A. \"&x\"",
      "B. 1",
      "D. NULL"
    ],
    "correct": "C"
  },
  {
    "id": 326,
    "text": "Dato int x=1 e int *xPtr = &x, l'istruzione   printf(\"%p\", xPtr); stampa:",
    "options": [
      "A. \"xPtr\"",
      "B. 1",
      "D. NULL"
    ],
    "correct": "C"
  },
  {
    "id": 327,
    "text": "Dato int x=1 e int *xPtr = &x, l'istruzione   printf(\"%d\", *xPtr); stampa:",
    "options": [
      "A. \"*xPtr\"",
      "B. 1",
      "D. NULL"
    ],
    "correct": "B"
  },
  {
    "id": 328,
    "text": "Nel passaggio per valore,  una funzione chiamata dal main:",
    "options": [
      "A. riceve un puntatore alle variabili passate dal main. Non ci sono limiti al numero di variabili passate",
      "B. riceve una copia del valore delle variabili passate dal main. Non ci sono limiti al numero di variabili passate",
      "C. riceve un puntatore alla variabile passata dal main. Il main puo' passare una sola variabile",
      "D. riceve una copia del valore della variabile passata dal main. Il main puo' passare una sola variabile"
    ],
    "correct": "B"
  },
  {
    "id": 329,
    "text": "Nel passaggi o per valore, una funzione chiamata dal main:",
    "options": [
      "A. restituisce un puntatore. Non ci sono limiti al numero di puntatori restituiti al main",
      "B. restituisce i valore delle variabili modificate dalla funzione. Non ci sono limiti sul numero di variabili modificate  che si  possono restituire al main",
      "C. restituisce un puntatore. La funzione puo' restituire un solo puntatore",
      "D. restituisce il valore della variabile modificata dalla funzione (al piu' un solo valore)"
    ],
    "correct": "D"
  },
  {
    "id": 330,
    "text": "Con il pa ssaggio per riferimento viene consentito a una funzione di restituire:",
    "options": [
      "A. un solo valore alla funzione chiamante",
      "B. più valori alla funzione chiamante",
      "C. nessun valore alla funzione chiamante",
      "D. solo valori int alla funzione chiamante"
    ],
    "correct": "B"
  },
  {
    "id": 331,
    "text": "Quando si chiama una funzione con argomenti che devono essere modificati, vengono passati:",
    "options": [
      "B. i valro e gli indirizzi usando l'operatore OR",
      "C. i valori degli argomenti",
      "D. gli in dirizzi degli argomenti"
    ],
    "correct": "D"
  },
  {
    "id": 332,
    "text": "Il prototipo di una funzione funz che deve modificare il valore di una variabile intera, si scrive:",
    "options": [
      "A. void funz(int *pPtr);",
      "B. void funz(int &pPtr);",
      "C. void funz(int pPtr);",
      "D. void funz(int %pPtr);"
    ],
    "correct": "A"
  },
  {
    "id": 333,
    "text": "Nel main, il passaggio per indirizzo della variabile intera p si realizza con:",
    "options": [
      "A. funz(*p)",
      "C. funz(p)",
      "D. funz(%p)"
    ],
    "correct": "B"
  },
  {
    "id": 334,
    "text": "Nella funzion e chiamata, il quadrato della variabile intera passata per riferimento si realizza con:",
    "options": [
      "A. *pPtr = *pPtr * *pPtr",
      "B. &pPtr = &pPtr * &pPtr",
      "C. pPtr = pPtr * pPtr",
      "D. %pPtr = %pPtr * %pPtr"
    ],
    "correct": "A"
  },
  {
    "id": 335,
    "text": "Nel passaggio con rif erimento, la restituzione delle variabili modificate si realizza con:",
    "options": [
      "A. return",
      "B. printf e scanf",
      "C. la modifica del puntatore puntato dal valore della variabile",
      "D. la modifica della variabile puntata dal puntatore"
    ],
    "correct": "D"
  },
  {
    "id": 336,
    "text": "Per assegnare l'indirizzo della variabile val alla variabile puntatore valPtr si scrive:",
    "options": [
      "A. valPtr = &val",
      "B. *valPtr = &val",
      "C. &valPtr = *val",
      "D. &valPtr = val"
    ],
    "correct": "A"
  },
  {
    "id": 337,
    "text": "Dopo l'esecuzione di int i = 4; int * ptr = &i; *ptr = 1; si ottiene:",
    "options": [
      "A. i = 4",
      "B. errore per uso incorretto dell'operatore *",
      "C. i = 1",
      "D. errore per uso incorretto dell'operatore &"
    ],
    "correct": "C"
  },
  {
    "id": 338,
    "text": "La variabile vPtr può es sere inizializzata per puntare all'array v con:",
    "options": [
      "A. vPtr = v;",
      "B. vPtr = *v;",
      "C. vPtr = &v;",
      "D. vPtr = *v[0];"
    ],
    "correct": "A"
  },
  {
    "id": 339,
    "text": "L'aritmetica dei puntatori:",
    "options": [
      "A. restituisce errore",
      "B. non dipende dall'indirizzo a cui puntano i punt atori",
      "C. dipende dalla dimensione degli oggetti a cui puntano i puntatori",
      "D. dipende dall'indirizzo a cui puntano i puntatori"
    ],
    "correct": "C"
  },
  {
    "id": 340,
    "text": "Dato l'array v di interi a 4 byte e il puntatore vPtr=&v[0] di valore 5000 , l'i struzione vPtr+=2 restituisce il valore:",
    "options": [
      "A. 5000",
      "B. 5002",
      "C. 5008",
      "D. 5200"
    ],
    "correct": "C"
  },
  {
    "id": 341,
    "text": "Dato l'array v di char e il puntatore vPtr=&v[0] di valore 5000 , l'istru zione vPtr+=2 restituisce il valore:",
    "options": [
      "A. 5000",
      "B. 5002",
      "C. 5008",
      "D. 5200"
    ],
    "correct": "B"
  },
  {
    "id": 342,
    "text": "L'aritmetica dei puntatori è correttamente applicabile a puntatori riferiti ad array in quanto:",
    "options": [
      "A. le locazioni di memoria sono di dimens ione 4 oppure 2 byte",
      "B. le locazioni di memoria sono di dimensione 4 byte",
      "C. le locazioni di memoria sono posizionate casualmente",
      "D. le locazioni di memoria sono contigue"
    ],
    "correct": "D"
  },
  {
    "id": 343,
    "text": "Dato l'array v di int e il puntatore vPtr=&v[0], l'istruzione vPtr++;:",
    "options": [
      "A. incrementa un puntatore di un array di uno",
      "B. incrementa il valore puntato di uno",
      "D. restituisce errore perché la versione correttà e' solo  ++vPtr;"
    ],
    "correct": "A"
  },
  {
    "id": 344,
    "text": "Dato l'array v di interi a 4 byte e due suoi puntatori vPtr che contiene l'indirizzo 500 e v2Ptr che contiene  l'indirizzo 508, l'istruzione x = v2Ptr -  vPtr; restiuisce:",
    "options": [
      "A. 0",
      "B. 2",
      "C. 8",
      "D. Errore, n on si puo' sottrarre un puntatore da un altro"
    ],
    "correct": "B"
  },
  {
    "id": 345,
    "text": "Dati gli array v e p di interi a 4 byte e loro puntatori vPtr e pPtr rispettivamente, l'istruzione x = vPtr -   pPtr;  restiuisce:",
    "options": [
      "A. 0",
      "B. 4",
      "C. Errore,  non si puo' sottrarre un puntatore da un altro se relativo ad array differente",
      "D. Errore, non si puo' sottrarre un puntatore da un altro"
    ],
    "correct": "C"
  },
  {
    "id": 346,
    "text": "Un puntatore può essere assegnato a un altro puntatore se  entrambi hanno lo stesso :",
    "options": [
      "A. specificatore di conversione",
      "B. prototipo di funzione",
      "C. tipo",
      "D. valore"
    ],
    "correct": "C"
  },
  {
    "id": 347,
    "text": "A tutti i tipi di puntatore è possibile assegnare un puntatore a:",
    "options": [
      "A. char",
      "B. long long int",
      "C. int",
      "D. void"
    ],
    "correct": "D"
  },
  {
    "id": 348,
    "text": "Dato bPtr = &b[0], l'elemento b[100] dell'array è equivalente a:",
    "options": [
      "A. &(bPtr + 100)",
      "B. *(bPtr + 100)",
      "C. *bPtr + 100",
      "D. bPtr + 100"
    ],
    "correct": "B"
  },
  {
    "id": 349,
    "text": "Dato bPtr puntatore al primo elemento di un array, l'offset indica:",
    "options": [
      "A. a quale elemento dell'array si fa riferimento",
      "B. l'indirizzo della locazione di memoria di bPtr in esadecimale",
      "C. il tipo di dato dell'array",
      "D. il v alore memorizzato all'indice zero dell'array"
    ],
    "correct": "A"
  },
  {
    "id": 350,
    "text": "Con la notazione \"puntatore/offset\", il valore dell'offset è:",
    "options": [
      "A. l'indice dell'array",
      "B. zero",
      "C. la dimenzione dell'array",
      "D. NULL"
    ],
    "correct": "A"
  },
  {
    "id": 351,
    "text": "Nella notazione \"puntatore/indice\", se bPtr ha il valore di b (array), l'espressione corretta per riferirsi al primo elemento è:",
    "options": [
      "A. bPtr[1]",
      "B. bPtr(1)",
      "C. bPtr*1",
      "D. bPtr"
    ],
    "correct": "A"
  },
  {
    "id": 352,
    "text": "Dato b array di int, l'espressione b+=3 è:",
    "options": [
      "A. scorretta poiché non verifica a priori se l'array ha dimensione minore di tre",
      "B. corretta",
      "C. scorretta poiché sarebbero servite le parentesi tonde per garantire le giuste precedenze",
      "D. scorretta poiché tenta di modificare il valore del nome dell'array"
    ],
    "correct": "D"
  },
  {
    "id": 353,
    "text": "Dato b array di int e int *bPtr = b, la notazione puntatore/offset con il nome dell'array come puntatore, per  riferirsi all'elemento i utilizza:",
    "options": [
      "B. *(b  + i)",
      "C. bPtr[i]",
      "D. *(bPtr + i)"
    ],
    "correct": "B"
  },
  {
    "id": 354,
    "text": "Dato b array di int e int *bPtr = b, la notazione puntatore/offset con un puntatore, per riferirsi all'elemento i utilizza:",
    "options": [
      "A. b[i]",
      "B. *(b + i)",
      "C. bPtr[i]",
      "D. *(bPtr + i)"
    ],
    "correct": "D"
  },
  {
    "id": 355,
    "text": "Dato b array di int e int *bPtr = b, la notazione degli array con indicizzazione dei puntatori, per riferirsi all'elemento i utilizza:",
    "options": [
      "A. b[i]",
      "B. *(b + i)",
      "C. bPtr[i]",
      "D. *(bPtr + i)"
    ],
    "correct": "C"
  },
  {
    "id": 356,
    "text": "Dato b array di int e int *bPtr = b, la notazione degli array con indice (indicizzazione di un array), per riferirsi  all'elemento i utilizza:",
    "options": [
      "A. b[i]",
      "B. *(b + i)",
      "C. bPtr[i]",
      "D. *(bPtr + i)"
    ],
    "correct": "A"
  },
  {
    "id": 357,
    "text": "L'istruzione s1[2]=s2[3]:",
    "options": [
      "A. assegna il valore di s2 all'indice 2 all'array s1 nell'indice 3",
      "B. assegna il valore di s1 all'indice 2 all'array s2 nell'indice 3",
      "C. assegna il valore di s2 all'indice 3 all'array s1 nell'indice 2",
      "D. assegna il valore di s1 all'in dice 3 all'array s2 nell'indice 2"
    ],
    "correct": "C"
  },
  {
    "id": 358,
    "text": "Un puntatore a una funzione contiene:",
    "options": [
      "A. i parametri iniziali passati alla funzione",
      "B. il valore finale restituito dalla fu nzione",
      "C. il tipo di dato restituito della funzione",
      "D. l'indirizzo della funzione nella memoria"
    ],
    "correct": "D"
  },
  {
    "id": 359,
    "text": "Il nome di un array è:",
    "options": [
      "A. l'indirizzo in memoria dell'ultimo elemento dell'array",
      "B. l'indirizzo in memoria del primo elemento dell'array",
      "C. il tipo di dato dell'array",
      "D. il valore memorizzato all'indice zero dell'array"
    ],
    "correct": "B"
  },
  {
    "id": 360,
    "text": "Il nome di una funzione è in realtà:",
    "options": [
      "A. l'indirizzo in memoria dell'elemento zero del primo array usato dalla funzione",
      "B. l'indirizzo in memoria di partenza del codice che esegue il compito della funzione",
      "C. l'indirizzo in memoria della fine  del codice che esegue il compito della funzione",
      "D. il valore memorizzato all'indice zero del primo array usato dalla funzione"
    ],
    "correct": "B"
  },
  {
    "id": 361,
    "text": "Int (*funz)(double a) indica che funz è:",
    "options": [
      "A. un puntatore a una funzione che riceve un parametro double e restituisce un risultato intero",
      "B. un puntatore a una funzione che riceve un parametro int e restituisce un risultato double",
      "C. una funzione che riceve un puntatore a un parametro int e restituisce un risultato doubl e",
      "D. una funzione che riceve un puntatore a un parametro double e restituisce un risultato intero"
    ],
    "correct": "A"
  },
  {
    "id": 362,
    "text": "Il prototipo int (*)(int); è:",
    "options": [
      "A. È errato, a causa di (*)",
      "B. È errato, a cuasa di (int)",
      "C. È corretto",
      "D. È errato, a causa della sequenza di (*) con (int)"
    ],
    "correct": "C"
  },
  {
    "id": 363,
    "text": "Un uso comune dei puntatori a funzioni si ha nei:",
    "options": [
      "A. sistemi matematici",
      "B. cicli infiniti",
      "D. nei programmi privi di funzioni"
    ],
    "correct": "C"
  },
  {
    "id": 364,
    "text": "Una restrizione all'uso di array di puntatori a funzioni è costituita dal fatto che:",
    "options": [
      "A. tutti i puntatori devono avere lo stesso tipo",
      "B. tutte le funzioni devono restituire void",
      "C. tutte le funzioni devono ricevere argomenti int",
      "D. tutti i puntatori devono puntare alla stessa locazione di memoria"
    ],
    "correct": "A"
  },
  {
    "id": 365,
    "text": "Indicate l'intestazione corretta per una funzione chiamata fun1 che re stituisce un intero e che riceve come  parametri l'intero x e un puntatore alla funzione fun",
    "options": [],
    "correct": ""
  },
  {
    "id": 366,
    "text": "La funzione fun2 riceve un parametro intero e restituisce un  intero.:",
    "options": [
      "A. int fun1 (int x, int (*fun2)(int))",
      "B. int fun2(int x, int (*fun1)(int))",
      "C. int fun1 (int x, int (fun2)(int))",
      "D. int fun2(int x, int (fun1)(int))"
    ],
    "correct": "A"
  },
  {
    "id": 367,
    "text": "Indicate l'intestazione corretta per una funzione chiamata fun1 che riceve come parametri due puntatori ai numeri in virgola mobile x e y e non restitui sce alcun valore:",
    "options": [
      "A. void fun1 (float x, float y)",
      "B. void fun1 (float &x, float &y)",
      "C. void (*)fun1 (float x, float y)",
      "D. void fun1 (float *x, float *y)"
    ],
    "correct": "D"
  },
  {
    "id": 368,
    "text": "Indicare la dichiarazione corretta di un array di 3 pu ntatori a funzioni che ricevono ognuna un argomento  int e  restituiscono void:",
    "options": [
      "A. int (*f[3])(void)",
      "B. void (*f[3])(int)",
      "C. void (int) (*f[3])",
      "D. void (f[3])(int)"
    ],
    "correct": "B"
  }
]